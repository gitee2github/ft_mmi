Copyright (c) 2021-2022 Huawei Device Co., Ltd.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

diff -Naur old/BUILD.gn new/BUILD.gn
--- old/BUILD.gn	2021-01-01 00:00:00.000000000 +0800
+++ new/BUILD.gn	2021-01-01 00:00:00.000000000 +0800
@@ -21,9 +21,16 @@
 config("libinput-third_public_config") {
   include_dirs = [
     "export_include",
+    "include",
+    "//third_party/FreeBSD/sys/dev/evdev",
+    "src",
   ]

   cflags = [
+    "-DHAVE_LIBEVDEV_DISABLE_PROPERTY=0",
+    "-DHAVE_LIBWACOM=0",
+    "-DHAVE_LOCALE_H=1",
+    "-UHAVE_VERSIONSORT",
   ]
 }

@@ -61,7 +68,8 @@
     "src/path-seat.c",
     "src/udev-seat.c",
     "src/timer.c",
-#    "src/libinput-util.c",
+    "src/libinput-util.c",
+    "src/evdev-joystick.c",
   ]

   configs = [
@@ -81,7 +89,7 @@
     "//third_party/mtdev:libmtdev",
   ]

-  part_name = "multimodalinput_base"
+  part_name = "input"
 }
 ## Build libinput-third.so }}}

@@ -113,7 +121,7 @@
     "//third_party/mtdev:libmtdev",
   ]

-  part_name = "multimodalinput_base"
+  part_name = "input"
 }

 ohos_executable("libinput-list") {
@@ -143,7 +151,7 @@
     "//third_party/mtdev:libmtdev",
   ]

-  part_name = "multimodalinput_base"
+  part_name = "input"
 }

 ohos_executable("libinput-tablet") {
@@ -173,5 +181,5 @@
     "//third_party/mtdev:libmtdev",
   ]

-  part_name = "multimodalinput_base"
+  part_name = "input"
 }
\ No newline at end of file
diff -Naur old/export_include/libinput.h new/export_include/libinput.h
--- old/export_include/libinput.h	2021-01-01 00:00:00.000000000 +0800
+++ new/export_include/libinput.h	2021-01-01 00:00:00.000000000 +0800
@@ -196,6 +196,22 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = 1 << 0,
+    EVDEV_UDEV_TAG_KEYBOARD = 1 << 1,
+    EVDEV_UDEV_TAG_MOUSE = 1 << 2,
+    EVDEV_UDEV_TAG_TOUCHPAD = 1 << 3,
+    EVDEV_UDEV_TAG_TOUCHSCREEN = 1 << 4,
+    EVDEV_UDEV_TAG_TABLET = 1 << 5,
+    EVDEV_UDEV_TAG_JOYSTICK = 1 << 6,
+    EVDEV_UDEV_TAG_ACCELEROMETER = 1 << 7,
+    EVDEV_UDEV_TAG_TABLET_PAD = 1 << 8,
+    EVDEV_UDEV_TAG_POINTINGSTICK = 1 << 9,
+    EVDEV_UDEV_TAG_TRACKBALL = 1 << 10,
+    EVDEV_UDEV_TAG_SWITCH = 1 << 11,
 };

 /**
@@ -315,6 +331,49 @@
 };

 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOW = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = 1 << 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = 1 << 1,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = 1 << 2,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = 1 << 3,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = 1 << 4,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = 1 << 5,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = 1 << 6,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = 1 << 7,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = 1 << 8,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = 1 << 9,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = 1 << 10,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = 1 << 11,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = 1 << 12,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = 1 << 13,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = 1 << 14,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = 1 << 15,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = 1 << 16,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = 1 << 17,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = 1 << 18,
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	int32_t is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -387,6 +446,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };

+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -754,6 +824,10 @@
 	 */
 	LIBINPUT_EVENT_TOUCH_FRAME,

+	LIBINPUT_EVENT_TOUCHPAD_DOWN = 550,
+	LIBINPUT_EVENT_TOUCHPAD_UP,
+	LIBINPUT_EVENT_TOUCHPAD_MOTION,
+
 	/**
 	 * One or more axes have changed state on a device with the @ref
 	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
@@ -1001,6 +1075,19 @@
 /**
  * @ingroup event
  *
+ * Return the touchpad event that is this input event. If the event type does
+ * not match the touchpad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touchpad_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
  * Return the gesture event that is this input event. If the event type does
  * not match the gesture event types, this function returns NULL.
  *
@@ -1673,6 +1760,120 @@
 				       uint32_t height);

 /**
+ * @brief 获取触摸屏的工具类型区域属性
+ */
+int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_x_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_y_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area. To get the corresponding output
+ * screen width, use
+ * libinput_event_touch_get_tool_width_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current width
+ */
+double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area, converted to screen width.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return Convert current width to screen width
+ */
+double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area. To get the corresponding output
+ * screen height, use
+ * libinput_event_touch_get_tool_height_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current height
+ */
+double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area, converted to screen height.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return Convert current height to screen height
+ */
+double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
  * @ingroup event_touch
  *
  * @return The generic libinput_event of this event
@@ -1681,6 +1882,228 @@
 libinput_event_touch_get_base_event(struct libinput_event_touch *event);

 /**
+ * @defgroup event_touch Touchpad events
+ *
+ * Events from absolute touchpad devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touchpad event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touchpad event has no assigned slot, for example if it is from a
+ * single touchpad device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The slot of this touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touchpad event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touchpad point.
+ *
+ * Events from single touchpad devices will be represented as one individual
+ * touchpad point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The seat slot of the touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the pressure of the touch pad
+ *
+ * @param event The libinput touch event
+ * @return Touchpad pressure value
+ *
+ */
+double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The long axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The short axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板的工具类型区域属性
+ */
+int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板工具类型按钮是否按下
+ */
+int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the X coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The X coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the Y coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The Y coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the width of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The width of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the height of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The height of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event);
+
+/**
  * @defgroup event_gesture Gesture events
  *
  * Gesture events are generated when a gesture is recognized on a touchpad.
@@ -1893,6 +2316,42 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);

 /**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
+ * @brief Obtain the device values the EV_LED event type
+ *
+ * @param device  A current input device
+ * @return int Obtained is Supported
+ */
+int libinput_has_event_led_type(struct libinput_device *device);
+
+/**
+ * @brief Obtain the function key enablement status of a keyboard device
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @return int Obtained state
+ */
+int libinput_get_funckey_state(struct libinput_device *device, unsigned int code);
+
+/**
+ * @brief Turn an LED on or off. Convenience function, if you need to modify multiple
+ * LEDs simultaneously, use libinput_set_led_state() instead.
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @param state value Specifies whether to turn the LED on or off
+ * @return int 0 on success, or a negative errno on failure
+ */
+int libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -2620,6 +3079,19 @@
 /**
  * @ingroup event_tablet
  *
+ * Get the stylus event type reported from evdev_tablet
+ *
+ * @param event The libinput tablet tool event
+ * @return Tool type for stylus events
+ *
+ * @since 1.2
+ */
+int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
  * Return the high-level tool type for a tool object.
  *
  * The high level tool describes general interaction expected with the tool.
@@ -3466,6 +3938,46 @@
 int
 libinput_dispatch(struct libinput *libinput);

+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_axis *
+libinput_event_get_joystick_axis_event(struct libinput_event *event);
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -3936,6 +4448,42 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);

+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
+/**  @brief   设备按键能力查询*/
+int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode);
+
+/**  @brief   获取设备特定轴的最小值*/
+int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的最大值*/
+int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的fuzz值*/
+int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的flat值*/
+int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的resolution值*/
+int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备的bustype值*/
+unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device);
+
+/**  @brief   获取设备的version值*/
+unsigned int
+libinput_device_get_id_version(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -4146,6 +4694,12 @@
 libinput_device_touch_get_touch_count(struct libinput_device *device);

 /**
+ * @brief 获取触摸屏工具类型按钮是否按下
+ */
+int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
  * @ingroup device
  *
  * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
@@ -5928,7 +6482,102 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);

+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ *
+ * @since 1.4
+ */
+double
+libinput_event_touch_get_pressure(struct libinput_event_touch* event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Long axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Short axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+
+const char*
+libinput_device_get_uniq(struct libinput_device* device);
+
+enum libinput_key_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/hm_src/hm_missing.c new/hm_src/hm_missing.c
--- old/hm_src/hm_missing.c	1970-01-01 08:00:00.000000000 +0800
+++ new/hm_src/hm_missing.c	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hm_missing.h"
+
+extern char *__progname;
+char *ohos_program_invocation_short_name()
+{
+    return __progname;
+}
\ No newline at end of file
diff -Naur old/hm_src/hm_missing.h new/hm_src/hm_missing.h
--- old/hm_src/hm_missing.h	1970-01-01 08:00:00.000000000 +0800
+++ new/hm_src/hm_missing.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_LIBINPUT_HM_MISSING_H
+#define OHOS_LIBINPUT_HM_MISSING_H
+
+/* The full and simple forms of the name with which the program was
+   invoked.  These variables are set up automatically at startup based on
+   the value of argv[0].  */
+extern char *ohos_program_invocation_short_name();
+#define program_invocation_short_name ohos_program_invocation_short_name()
+
+#endif
diff -Naur old/include/config.h new/include/config.h
--- old/include/config.h	2021-01-01 00:00:00.000000000 +0800
+++ new/include/config.h	2021-01-01 00:00:00.000000000 +0800
@@ -18,14 +18,17 @@
 #endif
 #define HTTP_DOC_LINK "https://wayland.freedesktop.org/libinput/doc/latest"

-#define LIBINPUT_QUIRKS_DIR "/usr/share/libinput"
+#define LIBINPUT_QUIRKS_DIR "/etc/libinput/quirks"

-#define LIBINPUT_QUIRKS_OVERRIDE_FILE "/etc/libinput/local-overrides.quirks"
+#define LIBINPUT_QUIRKS_OVERRIDE_FILE "/etc/libinput/quirks/local-overrides.quirks"
+
+#define LIBINPUT_QUIRKS_SRCDIR "/etc/libinput/quirks"
+
+#define LIBINPUT_TOOL_PATH "/data/libinput"
+
+#define MESON_BUILD_ROOT "/data/libinput"

 #undef NDEBUG
-#define LIBINPUT_TOOL_PATH ""
-#define LIBINPUT_QUIRKS_SRCDIR ""
-#define MESON_BUILD_ROOT ""
 #ifndef static_assert
 # ifdef _Static_assert
 #  define static_assert(cond, msg) _Static_assert(cond, msg)
@@ -36,3 +39,10 @@

 #define index strchr
 #define ffs __builtin_ffs
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+#define _LIBINPUT_LOG_DIR "/data/log/libinput"
+#define _LIBINPUT_LOG_PATH "/data/log/libinput/libinput.log"
+#endif
+
+
diff -Naur old/include/linux/linux/input-event-codes.h new/include/linux/linux/input-event-codes.h
--- old/include/linux/linux/input-event-codes.h	2021-01-01 00:00:00.000000000 +0800
+++ new/include/linux/linux/input-event-codes.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,945 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
-/*
- * Input event codes
- *
- *    *** IMPORTANT ***
- * This file is not only included from C-code but also from devicetree source
- * files. As such this file MUST only contain comments and defines.
- *
- * Copyright (c) 1999-2002 Vojtech Pavlik
- * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- */
-#ifndef _UAPI_INPUT_EVENT_CODES_H
-#define _UAPI_INPUT_EVENT_CODES_H
-
-/*
- * Device properties and quirks
- */
-
-#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
-#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
-#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
-#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
-#define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
-#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
-#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
-
-#define INPUT_PROP_MAX			0x1f
-#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
-
-/*
- * Event types
- */
-
-#define EV_SYN			0x00
-#define EV_KEY			0x01
-#define EV_REL			0x02
-#define EV_ABS			0x03
-#define EV_MSC			0x04
-#define EV_SW			0x05
-#define EV_LED			0x11
-#define EV_SND			0x12
-#define EV_REP			0x14
-#define EV_FF			0x15
-#define EV_PWR			0x16
-#define EV_FF_STATUS		0x17
-#define EV_MAX			0x1f
-#define EV_CNT			(EV_MAX+1)
-
-/*
- * Synchronization events.
- */
-
-#define SYN_REPORT		0
-#define SYN_CONFIG		1
-#define SYN_MT_REPORT		2
-#define SYN_DROPPED		3
-#define SYN_MAX			0xf
-#define SYN_CNT			(SYN_MAX+1)
-
-/*
- * Keys and buttons
- *
- * Most of the keys/buttons are modeled after USB HUT 1.12
- * (see http://www.usb.org/developers/hidpage).
- * Abbreviations in the comments:
- * AC - Application Control
- * AL - Application Launch Button
- * SC - System Control
- */
-
-#define KEY_RESERVED		0
-#define KEY_ESC			1
-#define KEY_1			2
-#define KEY_2			3
-#define KEY_3			4
-#define KEY_4			5
-#define KEY_5			6
-#define KEY_6			7
-#define KEY_7			8
-#define KEY_8			9
-#define KEY_9			10
-#define KEY_0			11
-#define KEY_MINUS		12
-#define KEY_EQUAL		13
-#define KEY_BACKSPACE		14
-#define KEY_TAB			15
-#define KEY_Q			16
-#define KEY_W			17
-#define KEY_E			18
-#define KEY_R			19
-#define KEY_T			20
-#define KEY_Y			21
-#define KEY_U			22
-#define KEY_I			23
-#define KEY_O			24
-#define KEY_P			25
-#define KEY_LEFTBRACE		26
-#define KEY_RIGHTBRACE		27
-#define KEY_ENTER		28
-#define KEY_LEFTCTRL		29
-#define KEY_A			30
-#define KEY_S			31
-#define KEY_D			32
-#define KEY_F			33
-#define KEY_G			34
-#define KEY_H			35
-#define KEY_J			36
-#define KEY_K			37
-#define KEY_L			38
-#define KEY_SEMICOLON		39
-#define KEY_APOSTROPHE		40
-#define KEY_GRAVE		41
-#define KEY_LEFTSHIFT		42
-#define KEY_BACKSLASH		43
-#define KEY_Z			44
-#define KEY_X			45
-#define KEY_C			46
-#define KEY_V			47
-#define KEY_B			48
-#define KEY_N			49
-#define KEY_M			50
-#define KEY_COMMA		51
-#define KEY_DOT			52
-#define KEY_SLASH		53
-#define KEY_RIGHTSHIFT		54
-#define KEY_KPASTERISK		55
-#define KEY_LEFTALT		56
-#define KEY_SPACE		57
-#define KEY_CAPSLOCK		58
-#define KEY_F1			59
-#define KEY_F2			60
-#define KEY_F3			61
-#define KEY_F4			62
-#define KEY_F5			63
-#define KEY_F6			64
-#define KEY_F7			65
-#define KEY_F8			66
-#define KEY_F9			67
-#define KEY_F10			68
-#define KEY_NUMLOCK		69
-#define KEY_SCROLLLOCK		70
-#define KEY_KP7			71
-#define KEY_KP8			72
-#define KEY_KP9			73
-#define KEY_KPMINUS		74
-#define KEY_KP4			75
-#define KEY_KP5			76
-#define KEY_KP6			77
-#define KEY_KPPLUS		78
-#define KEY_KP1			79
-#define KEY_KP2			80
-#define KEY_KP3			81
-#define KEY_KP0			82
-#define KEY_KPDOT		83
-
-#define KEY_ZENKAKUHANKAKU	85
-#define KEY_102ND		86
-#define KEY_F11			87
-#define KEY_F12			88
-#define KEY_RO			89
-#define KEY_KATAKANA		90
-#define KEY_HIRAGANA		91
-#define KEY_HENKAN		92
-#define KEY_KATAKANAHIRAGANA	93
-#define KEY_MUHENKAN		94
-#define KEY_KPJPCOMMA		95
-#define KEY_KPENTER		96
-#define KEY_RIGHTCTRL		97
-#define KEY_KPSLASH		98
-#define KEY_SYSRQ		99
-#define KEY_RIGHTALT		100
-#define KEY_LINEFEED		101
-#define KEY_HOME		102
-#define KEY_UP			103
-#define KEY_PAGEUP		104
-#define KEY_LEFT		105
-#define KEY_RIGHT		106
-#define KEY_END			107
-#define KEY_DOWN		108
-#define KEY_PAGEDOWN		109
-#define KEY_INSERT		110
-#define KEY_DELETE		111
-#define KEY_MACRO		112
-#define KEY_MUTE		113
-#define KEY_VOLUMEDOWN		114
-#define KEY_VOLUMEUP		115
-#define KEY_POWER		116	/* SC System Power Down */
-#define KEY_KPEQUAL		117
-#define KEY_KPPLUSMINUS		118
-#define KEY_PAUSE		119
-#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
-
-#define KEY_KPCOMMA		121
-#define KEY_HANGEUL		122
-#define KEY_HANGUEL		KEY_HANGEUL
-#define KEY_HANJA		123
-#define KEY_YEN			124
-#define KEY_LEFTMETA		125
-#define KEY_RIGHTMETA		126
-#define KEY_COMPOSE		127
-
-#define KEY_STOP		128	/* AC Stop */
-#define KEY_AGAIN		129
-#define KEY_PROPS		130	/* AC Properties */
-#define KEY_UNDO		131	/* AC Undo */
-#define KEY_FRONT		132
-#define KEY_COPY		133	/* AC Copy */
-#define KEY_OPEN		134	/* AC Open */
-#define KEY_PASTE		135	/* AC Paste */
-#define KEY_FIND		136	/* AC Search */
-#define KEY_CUT			137	/* AC Cut */
-#define KEY_HELP		138	/* AL Integrated Help Center */
-#define KEY_MENU		139	/* Menu (show menu) */
-#define KEY_CALC		140	/* AL Calculator */
-#define KEY_SETUP		141
-#define KEY_SLEEP		142	/* SC System Sleep */
-#define KEY_WAKEUP		143	/* System Wake Up */
-#define KEY_FILE		144	/* AL Local Machine Browser */
-#define KEY_SENDFILE		145
-#define KEY_DELETEFILE		146
-#define KEY_XFER		147
-#define KEY_PROG1		148
-#define KEY_PROG2		149
-#define KEY_WWW			150	/* AL Internet Browser */
-#define KEY_MSDOS		151
-#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
-#define KEY_SCREENLOCK		KEY_COFFEE
-#define KEY_ROTATE_DISPLAY	153	/* Display orientation for e.g. tablets */
-#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
-#define KEY_CYCLEWINDOWS	154
-#define KEY_MAIL		155
-#define KEY_BOOKMARKS		156	/* AC Bookmarks */
-#define KEY_COMPUTER		157
-#define KEY_BACK		158	/* AC Back */
-#define KEY_FORWARD		159	/* AC Forward */
-#define KEY_CLOSECD		160
-#define KEY_EJECTCD		161
-#define KEY_EJECTCLOSECD	162
-#define KEY_NEXTSONG		163
-#define KEY_PLAYPAUSE		164
-#define KEY_PREVIOUSSONG	165
-#define KEY_STOPCD		166
-#define KEY_RECORD		167
-#define KEY_REWIND		168
-#define KEY_PHONE		169	/* Media Select Telephone */
-#define KEY_ISO			170
-#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
-#define KEY_HOMEPAGE		172	/* AC Home */
-#define KEY_REFRESH		173	/* AC Refresh */
-#define KEY_EXIT		174	/* AC Exit */
-#define KEY_MOVE		175
-#define KEY_EDIT		176
-#define KEY_SCROLLUP		177
-#define KEY_SCROLLDOWN		178
-#define KEY_KPLEFTPAREN		179
-#define KEY_KPRIGHTPAREN	180
-#define KEY_NEW			181	/* AC New */
-#define KEY_REDO		182	/* AC Redo/Repeat */
-
-#define KEY_F13			183
-#define KEY_F14			184
-#define KEY_F15			185
-#define KEY_F16			186
-#define KEY_F17			187
-#define KEY_F18			188
-#define KEY_F19			189
-#define KEY_F20			190
-#define KEY_F21			191
-#define KEY_F22			192
-#define KEY_F23			193
-#define KEY_F24			194
-
-#define KEY_PLAYCD		200
-#define KEY_PAUSECD		201
-#define KEY_PROG3		202
-#define KEY_PROG4		203
-#define KEY_DASHBOARD		204	/* AL Dashboard */
-#define KEY_SUSPEND		205
-#define KEY_CLOSE		206	/* AC Close */
-#define KEY_PLAY		207
-#define KEY_FASTFORWARD		208
-#define KEY_BASSBOOST		209
-#define KEY_PRINT		210	/* AC Print */
-#define KEY_HP			211
-#define KEY_CAMERA		212
-#define KEY_SOUND		213
-#define KEY_QUESTION		214
-#define KEY_EMAIL		215
-#define KEY_CHAT		216
-#define KEY_SEARCH		217
-#define KEY_CONNECT		218
-#define KEY_FINANCE		219	/* AL Checkbook/Finance */
-#define KEY_SPORT		220
-#define KEY_SHOP		221
-#define KEY_ALTERASE		222
-#define KEY_CANCEL		223	/* AC Cancel */
-#define KEY_BRIGHTNESSDOWN	224
-#define KEY_BRIGHTNESSUP	225
-#define KEY_MEDIA		226
-
-#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
-					   outputs (Monitor/LCD/TV-out/etc) */
-#define KEY_KBDILLUMTOGGLE	228
-#define KEY_KBDILLUMDOWN	229
-#define KEY_KBDILLUMUP		230
-
-#define KEY_SEND		231	/* AC Send */
-#define KEY_REPLY		232	/* AC Reply */
-#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
-#define KEY_SAVE		234	/* AC Save */
-#define KEY_DOCUMENTS		235
-
-#define KEY_BATTERY		236
-
-#define KEY_BLUETOOTH		237
-#define KEY_WLAN		238
-#define KEY_UWB			239
-
-#define KEY_UNKNOWN		240
-
-#define KEY_VIDEO_NEXT		241	/* drive next video source */
-#define KEY_VIDEO_PREV		242	/* drive previous video source */
-#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
-#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
-					  brightness control is off,
-					  rely on ambient */
-#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
-#define KEY_DISPLAY_OFF		245	/* display device to off state */
-
-#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
-#define KEY_WIMAX		KEY_WWAN
-#define KEY_RFKILL		247	/* Key that controls all radios */
-
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
-
-/* Code 255 is reserved for special needs of AT keyboard driver */
-
-#define BTN_MISC		0x100
-#define BTN_0			0x100
-#define BTN_1			0x101
-#define BTN_2			0x102
-#define BTN_3			0x103
-#define BTN_4			0x104
-#define BTN_5			0x105
-#define BTN_6			0x106
-#define BTN_7			0x107
-#define BTN_8			0x108
-#define BTN_9			0x109
-
-#define BTN_MOUSE		0x110
-#define BTN_LEFT		0x110
-#define BTN_RIGHT		0x111
-#define BTN_MIDDLE		0x112
-#define BTN_SIDE		0x113
-#define BTN_EXTRA		0x114
-#define BTN_FORWARD		0x115
-#define BTN_BACK		0x116
-#define BTN_TASK		0x117
-
-#define BTN_JOYSTICK		0x120
-#define BTN_TRIGGER		0x120
-#define BTN_THUMB		0x121
-#define BTN_THUMB2		0x122
-#define BTN_TOP			0x123
-#define BTN_TOP2		0x124
-#define BTN_PINKIE		0x125
-#define BTN_BASE		0x126
-#define BTN_BASE2		0x127
-#define BTN_BASE3		0x128
-#define BTN_BASE4		0x129
-#define BTN_BASE5		0x12a
-#define BTN_BASE6		0x12b
-#define BTN_DEAD		0x12f
-
-#define BTN_GAMEPAD		0x130
-#define BTN_SOUTH		0x130
-#define BTN_A			BTN_SOUTH
-#define BTN_EAST		0x131
-#define BTN_B			BTN_EAST
-#define BTN_C			0x132
-#define BTN_NORTH		0x133
-#define BTN_X			BTN_NORTH
-#define BTN_WEST		0x134
-#define BTN_Y			BTN_WEST
-#define BTN_Z			0x135
-#define BTN_TL			0x136
-#define BTN_TR			0x137
-#define BTN_TL2			0x138
-#define BTN_TR2			0x139
-#define BTN_SELECT		0x13a
-#define BTN_START		0x13b
-#define BTN_MODE		0x13c
-#define BTN_THUMBL		0x13d
-#define BTN_THUMBR		0x13e
-
-#define BTN_DIGI		0x140
-#define BTN_TOOL_PEN		0x140
-#define BTN_TOOL_RUBBER		0x141
-#define BTN_TOOL_BRUSH		0x142
-#define BTN_TOOL_PENCIL		0x143
-#define BTN_TOOL_AIRBRUSH	0x144
-#define BTN_TOOL_FINGER		0x145
-#define BTN_TOOL_MOUSE		0x146
-#define BTN_TOOL_LENS		0x147
-#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
-#define BTN_STYLUS3		0x149
-#define BTN_TOUCH		0x14a
-#define BTN_STYLUS		0x14b
-#define BTN_STYLUS2		0x14c
-#define BTN_TOOL_DOUBLETAP	0x14d
-#define BTN_TOOL_TRIPLETAP	0x14e
-#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
-
-#define BTN_WHEEL		0x150
-#define BTN_GEAR_DOWN		0x150
-#define BTN_GEAR_UP		0x151
-
-#define KEY_OK			0x160
-#define KEY_SELECT		0x161
-#define KEY_GOTO		0x162
-#define KEY_CLEAR		0x163
-#define KEY_POWER2		0x164
-#define KEY_OPTION		0x165
-#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
-#define KEY_TIME		0x167
-#define KEY_VENDOR		0x168
-#define KEY_ARCHIVE		0x169
-#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
-#define KEY_CHANNEL		0x16b
-#define KEY_FAVORITES		0x16c
-#define KEY_EPG			0x16d
-#define KEY_PVR			0x16e	/* Media Select Home */
-#define KEY_MHP			0x16f
-#define KEY_LANGUAGE		0x170
-#define KEY_TITLE		0x171
-#define KEY_SUBTITLE		0x172
-#define KEY_ANGLE		0x173
-#define KEY_FULL_SCREEN		0x174	/* AC View Toggle */
-#define KEY_ZOOM		KEY_FULL_SCREEN
-#define KEY_MODE		0x175
-#define KEY_KEYBOARD		0x176
-#define KEY_ASPECT_RATIO	0x177	/* HUTRR37: Aspect */
-#define KEY_SCREEN		KEY_ASPECT_RATIO
-#define KEY_PC			0x178	/* Media Select Computer */
-#define KEY_TV			0x179	/* Media Select TV */
-#define KEY_TV2			0x17a	/* Media Select Cable */
-#define KEY_VCR			0x17b	/* Media Select VCR */
-#define KEY_VCR2		0x17c	/* VCR Plus */
-#define KEY_SAT			0x17d	/* Media Select Satellite */
-#define KEY_SAT2		0x17e
-#define KEY_CD			0x17f	/* Media Select CD */
-#define KEY_TAPE		0x180	/* Media Select Tape */
-#define KEY_RADIO		0x181
-#define KEY_TUNER		0x182	/* Media Select Tuner */
-#define KEY_PLAYER		0x183
-#define KEY_TEXT		0x184
-#define KEY_DVD			0x185	/* Media Select DVD */
-#define KEY_AUX			0x186
-#define KEY_MP3			0x187
-#define KEY_AUDIO		0x188	/* AL Audio Browser */
-#define KEY_VIDEO		0x189	/* AL Movie Browser */
-#define KEY_DIRECTORY		0x18a
-#define KEY_LIST		0x18b
-#define KEY_MEMO		0x18c	/* Media Select Messages */
-#define KEY_CALENDAR		0x18d
-#define KEY_RED			0x18e
-#define KEY_GREEN		0x18f
-#define KEY_YELLOW		0x190
-#define KEY_BLUE		0x191
-#define KEY_CHANNELUP		0x192	/* Channel Increment */
-#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
-#define KEY_FIRST		0x194
-#define KEY_LAST		0x195	/* Recall Last */
-#define KEY_AB			0x196
-#define KEY_NEXT		0x197
-#define KEY_RESTART		0x198
-#define KEY_SLOW		0x199
-#define KEY_SHUFFLE		0x19a
-#define KEY_BREAK		0x19b
-#define KEY_PREVIOUS		0x19c
-#define KEY_DIGITS		0x19d
-#define KEY_TEEN		0x19e
-#define KEY_TWEN		0x19f
-#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
-#define KEY_GAMES		0x1a1	/* Media Select Games */
-#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
-#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
-#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
-#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
-#define KEY_EDITOR		0x1a6	/* AL Text Editor */
-#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
-#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
-#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
-#define KEY_DATABASE		0x1aa	/* AL Database App */
-#define KEY_NEWS		0x1ab	/* AL Newsreader */
-#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
-#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
-#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
-#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
-#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
-#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
-#define KEY_LOGOFF		0x1b1   /* AL Logoff */
-
-#define KEY_DOLLAR		0x1b2
-#define KEY_EURO		0x1b3
-
-#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
-#define KEY_FRAMEFORWARD	0x1b5
-#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
-#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
-#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
-#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
-#define KEY_IMAGES		0x1ba	/* AL Image Browser */
-
-#define KEY_DEL_EOL		0x1c0
-#define KEY_DEL_EOS		0x1c1
-#define KEY_INS_LINE		0x1c2
-#define KEY_DEL_LINE		0x1c3
-
-#define KEY_FN			0x1d0
-#define KEY_FN_ESC		0x1d1
-#define KEY_FN_F1		0x1d2
-#define KEY_FN_F2		0x1d3
-#define KEY_FN_F3		0x1d4
-#define KEY_FN_F4		0x1d5
-#define KEY_FN_F5		0x1d6
-#define KEY_FN_F6		0x1d7
-#define KEY_FN_F7		0x1d8
-#define KEY_FN_F8		0x1d9
-#define KEY_FN_F9		0x1da
-#define KEY_FN_F10		0x1db
-#define KEY_FN_F11		0x1dc
-#define KEY_FN_F12		0x1dd
-#define KEY_FN_1		0x1de
-#define KEY_FN_2		0x1df
-#define KEY_FN_D		0x1e0
-#define KEY_FN_E		0x1e1
-#define KEY_FN_F		0x1e2
-#define KEY_FN_S		0x1e3
-#define KEY_FN_B		0x1e4
-
-#define KEY_BRL_DOT1		0x1f1
-#define KEY_BRL_DOT2		0x1f2
-#define KEY_BRL_DOT3		0x1f3
-#define KEY_BRL_DOT4		0x1f4
-#define KEY_BRL_DOT5		0x1f5
-#define KEY_BRL_DOT6		0x1f6
-#define KEY_BRL_DOT7		0x1f7
-#define KEY_BRL_DOT8		0x1f8
-#define KEY_BRL_DOT9		0x1f9
-#define KEY_BRL_DOT10		0x1fa
-
-#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
-#define KEY_NUMERIC_1		0x201	/* and other keypads */
-#define KEY_NUMERIC_2		0x202
-#define KEY_NUMERIC_3		0x203
-#define KEY_NUMERIC_4		0x204
-#define KEY_NUMERIC_5		0x205
-#define KEY_NUMERIC_6		0x206
-#define KEY_NUMERIC_7		0x207
-#define KEY_NUMERIC_8		0x208
-#define KEY_NUMERIC_9		0x209
-#define KEY_NUMERIC_STAR	0x20a
-#define KEY_NUMERIC_POUND	0x20b
-#define KEY_NUMERIC_A		0x20c	/* Phone key A - HUT Telephony 0xb9 */
-#define KEY_NUMERIC_B		0x20d
-#define KEY_NUMERIC_C		0x20e
-#define KEY_NUMERIC_D		0x20f
-
-#define KEY_CAMERA_FOCUS	0x210
-#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
-
-#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
-#define KEY_TOUCHPAD_ON		0x213
-#define KEY_TOUCHPAD_OFF	0x214
-
-#define KEY_CAMERA_ZOOMIN	0x215
-#define KEY_CAMERA_ZOOMOUT	0x216
-#define KEY_CAMERA_UP		0x217
-#define KEY_CAMERA_DOWN		0x218
-#define KEY_CAMERA_LEFT		0x219
-#define KEY_CAMERA_RIGHT	0x21a
-
-#define KEY_ATTENDANT_ON	0x21b
-#define KEY_ATTENDANT_OFF	0x21c
-#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
-#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
-
-#define BTN_DPAD_UP		0x220
-#define BTN_DPAD_DOWN		0x221
-#define BTN_DPAD_LEFT		0x222
-#define BTN_DPAD_RIGHT		0x223
-
-#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
-#define KEY_ROTATE_LOCK_TOGGLE	0x231	/* Display rotation lock */
-
-#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
-#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
-#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
-#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
-#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
-#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
-#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
-#define KEY_ASSISTANT		0x247	/* AL Context-aware desktop assistant */
-#define KEY_KBD_LAYOUT_NEXT	0x248	/* AC Next Keyboard Layout Select */
-
-#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
-#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
-
-#define KEY_KBDINPUTASSIST_PREV		0x260
-#define KEY_KBDINPUTASSIST_NEXT		0x261
-#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
-#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
-#define KEY_KBDINPUTASSIST_ACCEPT		0x264
-#define KEY_KBDINPUTASSIST_CANCEL		0x265
-
-/* Diagonal movement keys */
-#define KEY_RIGHT_UP			0x266
-#define KEY_RIGHT_DOWN			0x267
-#define KEY_LEFT_UP			0x268
-#define KEY_LEFT_DOWN			0x269
-
-#define KEY_ROOT_MENU			0x26a /* Show Device's Root Menu */
-/* Show Top Menu of the Media (e.g. DVD) */
-#define KEY_MEDIA_TOP_MENU		0x26b
-#define KEY_NUMERIC_11			0x26c
-#define KEY_NUMERIC_12			0x26d
-/*
- * Toggle Audio Description: refers to an audio service that helps blind and
- * visually impaired consumers understand the action in a program. Note: in
- * some countries this is referred to as "Video Description".
- */
-#define KEY_AUDIO_DESC			0x26e
-#define KEY_3D_MODE			0x26f
-#define KEY_NEXT_FAVORITE		0x270
-#define KEY_STOP_RECORD			0x271
-#define KEY_PAUSE_RECORD		0x272
-#define KEY_VOD				0x273 /* Video on Demand */
-#define KEY_UNMUTE			0x274
-#define KEY_FASTREVERSE			0x275
-#define KEY_SLOWREVERSE			0x276
-/*
- * Control a data application associated with the currently viewed channel,
- * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
- */
-#define KEY_DATA			0x277
-#define KEY_ONSCREEN_KEYBOARD		0x278
-/* Electronic privacy screen control */
-#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
-
-/* Select an area of screen to be copied */
-#define KEY_SELECTIVE_SCREENSHOT	0x27a
-
-/*
- * Some keyboards have keys which do not have a defined meaning, these keys
- * are intended to be programmed / bound to macros by the user. For most
- * keyboards with these macro-keys the key-sequence to inject, or action to
- * take, is all handled by software on the host side. So from the kernel's
- * point of view these are just normal keys.
- *
- * The KEY_MACRO# codes below are intended for such keys, which may be labeled
- * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
- * where the marking on the key does indicate a defined meaning / purpose.
- *
- * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
- * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
- * define MUST be added.
- */
-#define KEY_MACRO1			0x290
-#define KEY_MACRO2			0x291
-#define KEY_MACRO3			0x292
-#define KEY_MACRO4			0x293
-#define KEY_MACRO5			0x294
-#define KEY_MACRO6			0x295
-#define KEY_MACRO7			0x296
-#define KEY_MACRO8			0x297
-#define KEY_MACRO9			0x298
-#define KEY_MACRO10			0x299
-#define KEY_MACRO11			0x29a
-#define KEY_MACRO12			0x29b
-#define KEY_MACRO13			0x29c
-#define KEY_MACRO14			0x29d
-#define KEY_MACRO15			0x29e
-#define KEY_MACRO16			0x29f
-#define KEY_MACRO17			0x2a0
-#define KEY_MACRO18			0x2a1
-#define KEY_MACRO19			0x2a2
-#define KEY_MACRO20			0x2a3
-#define KEY_MACRO21			0x2a4
-#define KEY_MACRO22			0x2a5
-#define KEY_MACRO23			0x2a6
-#define KEY_MACRO24			0x2a7
-#define KEY_MACRO25			0x2a8
-#define KEY_MACRO26			0x2a9
-#define KEY_MACRO27			0x2aa
-#define KEY_MACRO28			0x2ab
-#define KEY_MACRO29			0x2ac
-#define KEY_MACRO30			0x2ad
-
-/*
- * Some keyboards with the macro-keys described above have some extra keys
- * for controlling the host-side software responsible for the macro handling:
- * -A macro recording start/stop key. Note that not all keyboards which emit
- *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
- *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
- *  should be interpreted as a recording start/stop toggle;
- * -Keys for switching between different macro (pre)sets, either a key for
- *  cycling through the configured presets or keys to directly select a preset.
- */
-#define KEY_MACRO_RECORD_START		0x2b0
-#define KEY_MACRO_RECORD_STOP		0x2b1
-#define KEY_MACRO_PRESET_CYCLE		0x2b2
-#define KEY_MACRO_PRESET1		0x2b3
-#define KEY_MACRO_PRESET2		0x2b4
-#define KEY_MACRO_PRESET3		0x2b5
-
-/*
- * Some keyboards have a buildin LCD panel where the contents are controlled
- * by the host. Often these have a number of keys directly below the LCD
- * intended for controlling a menu shown on the LCD. These keys often don't
- * have any labeling so we just name them KEY_KBD_LCD_MENU#
- */
-#define KEY_KBD_LCD_MENU1		0x2b8
-#define KEY_KBD_LCD_MENU2		0x2b9
-#define KEY_KBD_LCD_MENU3		0x2ba
-#define KEY_KBD_LCD_MENU4		0x2bb
-#define KEY_KBD_LCD_MENU5		0x2bc
-
-#define BTN_TRIGGER_HAPPY		0x2c0
-#define BTN_TRIGGER_HAPPY1		0x2c0
-#define BTN_TRIGGER_HAPPY2		0x2c1
-#define BTN_TRIGGER_HAPPY3		0x2c2
-#define BTN_TRIGGER_HAPPY4		0x2c3
-#define BTN_TRIGGER_HAPPY5		0x2c4
-#define BTN_TRIGGER_HAPPY6		0x2c5
-#define BTN_TRIGGER_HAPPY7		0x2c6
-#define BTN_TRIGGER_HAPPY8		0x2c7
-#define BTN_TRIGGER_HAPPY9		0x2c8
-#define BTN_TRIGGER_HAPPY10		0x2c9
-#define BTN_TRIGGER_HAPPY11		0x2ca
-#define BTN_TRIGGER_HAPPY12		0x2cb
-#define BTN_TRIGGER_HAPPY13		0x2cc
-#define BTN_TRIGGER_HAPPY14		0x2cd
-#define BTN_TRIGGER_HAPPY15		0x2ce
-#define BTN_TRIGGER_HAPPY16		0x2cf
-#define BTN_TRIGGER_HAPPY17		0x2d0
-#define BTN_TRIGGER_HAPPY18		0x2d1
-#define BTN_TRIGGER_HAPPY19		0x2d2
-#define BTN_TRIGGER_HAPPY20		0x2d3
-#define BTN_TRIGGER_HAPPY21		0x2d4
-#define BTN_TRIGGER_HAPPY22		0x2d5
-#define BTN_TRIGGER_HAPPY23		0x2d6
-#define BTN_TRIGGER_HAPPY24		0x2d7
-#define BTN_TRIGGER_HAPPY25		0x2d8
-#define BTN_TRIGGER_HAPPY26		0x2d9
-#define BTN_TRIGGER_HAPPY27		0x2da
-#define BTN_TRIGGER_HAPPY28		0x2db
-#define BTN_TRIGGER_HAPPY29		0x2dc
-#define BTN_TRIGGER_HAPPY30		0x2dd
-#define BTN_TRIGGER_HAPPY31		0x2de
-#define BTN_TRIGGER_HAPPY32		0x2df
-#define BTN_TRIGGER_HAPPY33		0x2e0
-#define BTN_TRIGGER_HAPPY34		0x2e1
-#define BTN_TRIGGER_HAPPY35		0x2e2
-#define BTN_TRIGGER_HAPPY36		0x2e3
-#define BTN_TRIGGER_HAPPY37		0x2e4
-#define BTN_TRIGGER_HAPPY38		0x2e5
-#define BTN_TRIGGER_HAPPY39		0x2e6
-#define BTN_TRIGGER_HAPPY40		0x2e7
-
-/* We avoid low common keys in module aliases so they don't get huge. */
-#define KEY_MIN_INTERESTING	KEY_MUTE
-#define KEY_MAX			0x2ff
-#define KEY_CNT			(KEY_MAX+1)
-
-/*
- * Relative axes
- */
-
-#define REL_X			0x00
-#define REL_Y			0x01
-#define REL_Z			0x02
-#define REL_RX			0x03
-#define REL_RY			0x04
-#define REL_RZ			0x05
-#define REL_HWHEEL		0x06
-#define REL_DIAL		0x07
-#define REL_WHEEL		0x08
-#define REL_MISC		0x09
-/*
- * 0x0a is reserved and should not be used in input drivers.
- * It was used by HID as REL_MISC+1 and userspace needs to detect if
- * the next REL_* event is correct or is just REL_MISC + n.
- * We define here REL_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define REL_RESERVED		0x0a
-#define REL_WHEEL_HI_RES	0x0b
-#define REL_HWHEEL_HI_RES	0x0c
-#define REL_MAX			0x0f
-#define REL_CNT			(REL_MAX+1)
-
-/*
- * Absolute axes
- */
-
-#define ABS_X			0x00
-#define ABS_Y			0x01
-#define ABS_Z			0x02
-#define ABS_RX			0x03
-#define ABS_RY			0x04
-#define ABS_RZ			0x05
-#define ABS_THROTTLE		0x06
-#define ABS_RUDDER		0x07
-#define ABS_WHEEL		0x08
-#define ABS_GAS			0x09
-#define ABS_BRAKE		0x0a
-#define ABS_HAT0X		0x10
-#define ABS_HAT0Y		0x11
-#define ABS_HAT1X		0x12
-#define ABS_HAT1Y		0x13
-#define ABS_HAT2X		0x14
-#define ABS_HAT2Y		0x15
-#define ABS_HAT3X		0x16
-#define ABS_HAT3Y		0x17
-#define ABS_PRESSURE		0x18
-#define ABS_DISTANCE		0x19
-#define ABS_TILT_X		0x1a
-#define ABS_TILT_Y		0x1b
-#define ABS_TOOL_WIDTH		0x1c
-
-#define ABS_VOLUME		0x20
-
-#define ABS_MISC		0x28
-
-/*
- * 0x2e is reserved and should not be used in input drivers.
- * It was used by HID as ABS_MISC+6 and userspace needs to detect if
- * the next ABS_* event is correct or is just ABS_MISC + n.
- * We define here ABS_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define ABS_RESERVED		0x2e
-
-#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
-#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
-#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
-#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
-#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
-#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
-#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
-#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
-#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
-#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
-#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
-#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
-#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
-#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
-#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
-
-
-#define ABS_MAX			0x3f
-#define ABS_CNT			(ABS_MAX+1)
-
-/*
- * Switch events
- */
-
-#define SW_LID			0x00  /* set = lid shut */
-#define SW_TABLET_MODE		0x01  /* set = tablet mode */
-#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
-#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
-					 set = radio enabled */
-#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
-#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
-#define SW_DOCK			0x05  /* set = plugged into dock */
-#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
-#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
-#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
-#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
-#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
-#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
-#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
-#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
-#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
-#define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
-#define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_MAX			0x10
-#define SW_CNT			(SW_MAX+1)
-
-/*
- * Misc events
- */
-
-#define MSC_SERIAL		0x00
-#define MSC_PULSELED		0x01
-#define MSC_GESTURE		0x02
-#define MSC_RAW			0x03
-#define MSC_SCAN		0x04
-#define MSC_TIMESTAMP		0x05
-#define MSC_MAX			0x07
-#define MSC_CNT			(MSC_MAX+1)
-
-/*
- * LEDs
- */
-
-#define LED_NUML		0x00
-#define LED_CAPSL		0x01
-#define LED_SCROLLL		0x02
-#define LED_COMPOSE		0x03
-#define LED_KANA		0x04
-#define LED_SLEEP		0x05
-#define LED_SUSPEND		0x06
-#define LED_MUTE		0x07
-#define LED_MISC		0x08
-#define LED_MAIL		0x09
-#define LED_CHARGING		0x0a
-#define LED_MAX			0x0f
-#define LED_CNT			(LED_MAX+1)
-
-/*
- * Autorepeat values
- */
-
-#define REP_DELAY		0x00
-#define REP_PERIOD		0x01
-#define REP_MAX			0x01
-#define REP_CNT			(REP_MAX+1)
-
-/*
- * Sounds
- */
-
-#define SND_CLICK		0x00
-#define SND_BELL		0x01
-#define SND_TONE		0x02
-#define SND_MAX			0x07
-#define SND_CNT			(SND_MAX+1)
-
-#endif
diff -Naur old/src/evdev-fallback.c new/src/evdev-fallback.c
--- old/src/evdev-fallback.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-fallback.c	2021-01-01 00:00:00.000000000 +0800
@@ -284,8 +284,11 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	struct device_coords point;
+	struct device_coord_rect rect;
 	struct mt_slot *slot;
 	int seat_slot;
+	struct touch_axis axis;
+	int tool_type;

 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -308,8 +311,12 @@
 	slot->hysteresis_center = point;
 	evdev_transform_absolute(device, &point);

-	touch_notify_touch_down(base, time, slot_idx, seat_slot,
-				&point);
+	tool_type = slot->tool_type;
+	axis = slot->axis;
+	rect = slot->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touch_notify_touch_down(base, time, slot_idx, seat_slot, slot->pressure,
+				&axis, &point, tool_type, &rect);

 	return true;
 }
@@ -322,8 +329,11 @@
 {
 	struct libinput_device *base = &device->base;
 	struct device_coords point;
+	struct device_coord_rect rect;
 	struct mt_slot *slot;
 	int seat_slot;
+	struct touch_axis axis;
+	int tool_type;

 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -331,6 +341,7 @@
 	slot = &dispatch->mt.slots[slot_idx];
 	seat_slot = slot->seat_slot;
 	point = slot->point;
+    axis = slot->axis;

 	if (seat_slot == -1)
 		return false;
@@ -339,8 +350,12 @@
 		return false;

 	evdev_transform_absolute(device, &point);
-	touch_notify_touch_motion(base, time, slot_idx, seat_slot,
-				  &point);
+
+	tool_type = slot->tool_type;
+	rect = slot->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touch_notify_touch_motion(base, time, slot_idx, seat_slot, slot->pressure,
+				  &axis, &point, tool_type, &rect);

 	return true;
 }
@@ -355,6 +370,7 @@
 	struct libinput_seat *seat = base->seat;
 	struct mt_slot *slot;
 	int seat_slot;
+	int tool_type;

 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -368,7 +384,9 @@

 	seat->slot_map &= ~bit(seat_slot);

-	touch_notify_touch_up(base, time, slot_idx, seat_slot);
+	tool_type = slot->tool_type;
+
+	touch_notify_touch_up(base, time, slot_idx, seat_slot, tool_type);

 	return true;
 }
@@ -409,7 +427,11 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	struct device_coords point;
+	const struct device_coord_rect rect = { 0 };
+	const struct touch_axis axis = { 0 };
 	int seat_slot;
+	int tool_type;
+	int32_t pressure = dispatch->abs.pressure;

 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -431,7 +453,9 @@
 	point = dispatch->abs.point;
 	evdev_transform_absolute(device, &point);

-	touch_notify_touch_down(base, time, -1, seat_slot, &point);
+	tool_type = -1;
+
+	touch_notify_touch_down(base, time, -1, seat_slot, pressure, &axis, &point, tool_type, &rect);

 	return true;
 }
@@ -443,7 +467,11 @@
 {
 	struct libinput_device *base = &device->base;
 	struct device_coords point;
+	const struct device_coord_rect rect = {0};
+	const struct touch_axis axis = { 0 };
 	int seat_slot;
+	int tool_type;
+	int32_t pressure = dispatch->abs.pressure;

 	point = dispatch->abs.point;
 	evdev_transform_absolute(device, &point);
@@ -453,7 +481,9 @@
 	if (seat_slot == -1)
 		return false;

-	touch_notify_touch_motion(base, time, -1, seat_slot, &point);
+	tool_type = -1;
+
+	touch_notify_touch_motion(base, time, -1, seat_slot, pressure, &axis, &point, tool_type, &rect);

 	return true;
 }
@@ -466,6 +496,7 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	int seat_slot;
+	int tool_type;

 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -478,7 +509,9 @@

 	seat->slot_map &= ~bit(seat_slot);

-	touch_notify_touch_up(base, time, -1, seat_slot);
+	tool_type = -1;
+
+	touch_notify_touch_up(base, time, -1, seat_slot, tool_type);

 	return true;
 }
@@ -653,6 +686,42 @@
 			break;
 		}
 		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->tool_type = e->value;
+		slot->dirty = true;
+		break;
+	case ABS_MT_PRESSURE:
+        slot->pressure = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOUCH_MAJOR:
+        slot->axis.major = e->value;
+        dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+        slot->dirty = true;
+		break;
+    case ABS_MT_TOUCH_MINOR:
+        slot->axis.minor = e->value;
+        dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+        slot->dirty = true;
+        break;
+	case ABS_MT_WIDTH_MAJOR:
+		slot->tool_rect.w = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_WIDTH_MINOR:
+		slot->tool_rect.h = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOOL_X:
+		slot->tool_rect.x = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOOL_Y:
+		slot->tool_rect.y = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
 		slot->dirty = true;
 		break;
 	}
@@ -674,6 +743,10 @@
 		dispatch->abs.point.y = e->value;
 		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
 		break;
+	case ABS_PRESSURE:
+		dispatch->abs.pressure = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
+		break;
 	}
 }

@@ -1592,6 +1665,7 @@

 	for (slot = 0; slot < num_slots; ++slot) {
 		slots[slot].seat_slot = -1;
+		slots[slot].tool_type = -1;

 		if (evdev_need_mtdev(device))
 			continue;
@@ -1751,3 +1825,11 @@

 	return &dispatch->base;
 }
+
+bool
+evdev_device_touch_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType)
+{
+	struct fallback_dispatch *dispatch = fallback_dispatch(device->dispatch);
+
+	return hw_is_key_down(dispatch, btnToolType);
+}
diff -Naur old/src/evdev-fallback.h new/src/evdev-fallback.h
--- old/src/evdev-fallback.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-fallback.h	2021-01-01 00:00:00.000000000 +0800
@@ -66,6 +66,10 @@
 	struct device_coords point;
 	struct device_coords hysteresis_center;
 	enum palm_state palm_state;
+	struct device_coord_rect tool_rect;
+	int32_t pressure;
+	struct touch_axis axis;
+	int32_t tool_type;
 };

 struct fallback_dispatch {
@@ -84,6 +88,7 @@
 	struct {
 		struct device_coords point;
 		int32_t seat_slot;
+		int32_t pressure;
 	} abs;

 	struct {
@@ -169,6 +174,7 @@
 static inline enum key_type
 get_key_type(uint16_t code)
 {
+	const uint16_t KEY_ENDCALL = 0x2e8;
 	switch (code) {
 	case BTN_TOOL_PEN:
 	case BTN_TOOL_RUBBER:
@@ -198,6 +204,8 @@
 		return KEY_TYPE_KEY;
 	if (code >= BTN_TRIGGER_HAPPY && code <= BTN_TRIGGER_HAPPY40)
 		return KEY_TYPE_BUTTON;
+	if (code == KEY_ENDCALL)
+		return KEY_TYPE_KEY;
 	return KEY_TYPE_NONE;
 }

diff -Naur old/src/evdev-joystick.c new/src/evdev-joystick.c
--- old/src/evdev-joystick.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.c	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,580 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <string.h>
+
+#include "config.h"
+#include "libinput-version.h"
+#include "evdev-joystick.h"
+#include "input-event-codes.h"
+#include "libinput.h"
+#include "libinput-util.h"
+
+static inline struct
+joystick_dispatch* get_joystick_dispatch(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return NULL;
+    }
+    evdev_verify_dispatch_type(dispatch, DISPATCH_JOYSTICK);
+
+    struct joystick_dispatch* joystick_dispatch = NULL;
+    joystick_dispatch = container_of(dispatch, struct joystick_dispatch, base);
+
+    return joystick_dispatch;
+}
+
+static int
+update_seat_joystick_button_count(struct libinput_seat* pSeat, int32_t key, uint32_t *pRetcount, enum libinput_key_state state)
+{
+    if (pSeat == NULL || pRetcount == NULL || key < SYN_REPORT || key > KEY_MAX) {
+        return false;
+    }
+
+    switch (state) {
+        case LIBINPUT_KEY_STATE_PRESSED:
+        {
+            *(pRetcount) = ++pSeat->button_count[key];
+        }
+        break;
+        case LIBINPUT_KEY_STATE_RELEASED:
+        {
+            if (pSeat->button_count[key] == 0) {
+                *(pRetcount) = pSeat->button_count[key];
+            }
+            else {
+                *(pRetcount) = --pSeat->button_count[key];
+            }
+        }
+        break;
+        default:
+            *(pRetcount) = 0;
+            break;
+    }
+    return true;
+}
+
+static void
+joystick_notify_axis(struct evdev_device* device, uint64_t time)
+{
+    if (device == NULL) {
+        return;
+    }
+
+	struct joystick_dispatch *joystick_dispatch = get_joystick_dispatch(device->dispatch);
+	if (joystick_dispatch == NULL) {
+        libinput_log_printf("joystick_dispatch is NULL.\n");
+		return;
+	}
+
+    struct libinput_event_joystick_axis* joystick_axis_event = zalloc(sizeof * joystick_axis_event);
+    if (joystick_axis_event == NULL) {
+        libinput_log_printf("pJoystickEvent is NULL.\n");
+        return;
+    }
+
+    *joystick_axis_event = (struct libinput_event_joystick_axis){
+	    .base.type = LIBINPUT_EVENT_POINTER_AXIS,
+	    .base.device = &device->base,
+        .type = EV_ABS,
+        .time = time,
+        .axis_value_mask = joystick_dispatch->axis_value_mask,
+	    .abs_throttle = joystick_dispatch->abs_throttle,
+	    .abs_hat0x = joystick_dispatch->abs_hat0x,
+	    .abs_hat0y = joystick_dispatch->abs_hat0y,
+	    .abs_x = joystick_dispatch->abs_x,
+		.abs_y = joystick_dispatch->abs_y,
+		.abs_z = joystick_dispatch->abs_z,
+		.abs_rx = joystick_dispatch->abs_rx,
+		.abs_ry = joystick_dispatch->abs_ry,
+		.abs_rz = joystick_dispatch->abs_rz,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    struct libinput_event_listener* tmp_listener = NULL;
+    list_for_each_safe(listener, tmp_listener, &device->base.event_listeners, link) {
+        listener->notify_func(time, &joystick_axis_event->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &joystick_axis_event->base);
+}
+
+static void
+joystick_notify_key_event(struct evdev_device* device, struct input_event* pEvent, uint64_t time)
+{
+    if (device == NULL || pEvent == NULL) {
+        return;
+    }
+
+    struct libinput_event_joystick_button* pKeyEvent = {0};
+    uint32_t uiSeatCount = 0;
+
+    int iRet = update_seat_joystick_button_count(device->base.seat, pEvent->code, &uiSeatCount, pEvent->value);
+    if (iRet == false) {
+        return;
+    }
+
+    pKeyEvent = zalloc(sizeof * pKeyEvent);
+    if (pKeyEvent == NULL) {
+        return;
+    }
+
+	*pKeyEvent = (struct libinput_event_joystick_button) {
+			.base.type = LIBINPUT_EVENT_POINTER_BUTTON,
+			.base.device = &device->base,
+            .time = time,
+            .type = pEvent->type,
+            .key = pEvent->code,
+            .value = pEvent->value,
+            .seat_key_count = uiSeatCount,
+            .state = pEvent->value,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    struct libinput_event_listener* tmp_listener = NULL;
+    list_for_each_safe(listener, tmp_listener, &device->base.event_listeners, link)
+    {
+        listener->notify_func(time, &pKeyEvent->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &pKeyEvent->base);
+}
+
+static float
+abs_value_standardize(int32_t value, int32_t minimum, int32_t maximum, float standard_min, float standard_max)
+{
+    return standard_min + ((float)value - (float)minimum) * ((float)(standard_max - standard_min)) / ((float)(maximum - minimum));
+}
+
+static float
+get_joystick_abs_standard_value(struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    const int32_t value = absinfo->value;
+    const int32_t minimum = absinfo->minimum;
+    const int32_t maximum = absinfo->maximum;
+    if (minimum >= maximum) {
+		libinput_log_printf("joystick abs: minimum(%u) >= maximum(%u).\n", minimum, maximum);
+        return 0.f;
+    } else if (value < minimum || value > maximum) {
+		libinput_log_printf("joystick abs: value(%d) not between minimum(%u) and maximum(%u).\n", value, minimum, maximum);
+		return 0.f;
+    }
+
+    const int32_t code = absinfo->code;
+    switch (code) {
+	case ABS_THROTTLE:
+	{
+		return abs_value_standardize(value, minimum, maximum, 0, 1.0);
+	}
+	case ABS_X:
+	case ABS_Y:
+	case ABS_Z:
+	case ABS_RX:
+	case ABS_RY:
+	case ABS_RZ:
+    {
+        return abs_value_standardize(value, minimum, maximum, -1.0, 1.0);
+	}
+    case ABS_HAT0X:
+    case ABS_HAT0Y:
+    {
+        return (float)value;
+    }
+    default:
+    return (float)value;
+    }
+}
+
+static void joystick_set_axis_value_mask(struct joystick_dispatch *joystick_dispatch, enum libinput_joystick_axis_source axis)
+{
+    joystick_dispatch->axis_value_mask |= (uint32_t)axis;
+}
+
+static void joystick_reset_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	joystick_dispatch->axis_value_mask = 0;
+}
+
+static bool joystick_is_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	return (joystick_dispatch->axis_value_mask != 0);
+}
+
+static void joystick_get_one_abs_info(struct joystick_dispatch *joystick_dispatch, struct evdev_device *device, struct input_event *event,
+    const uint32_t code)
+{
+    struct libinput_event_joystick_axis_abs_info *absinfo = NULL;
+    switch (code) {
+    case ABS_THROTTLE:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE);
+    absinfo = &joystick_dispatch->abs_throttle;
+    break;
+    case ABS_HAT0X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X);
+    absinfo = &joystick_dispatch->abs_hat0x;
+    break;
+    case ABS_HAT0Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y);
+    absinfo = &joystick_dispatch->abs_hat0y;
+    break;
+    case ABS_X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X);
+    absinfo = &joystick_dispatch->abs_x;
+    break;
+    case ABS_Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y);
+    absinfo = &joystick_dispatch->abs_y;
+    break;
+	case ABS_Z:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z);
+	absinfo = &joystick_dispatch->abs_z;
+    break;
+	case ABS_RX:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX);
+	absinfo = &joystick_dispatch->abs_rx;
+	break;
+	case ABS_RY:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY);
+	absinfo = &joystick_dispatch->abs_ry;
+	break;
+    case ABS_RZ:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ);
+    absinfo = &joystick_dispatch->abs_rz;
+    break;
+    default:
+    break;
+    }
+
+    if (absinfo == NULL) {
+        libinput_log_printf("unsupported joystick abs event: divice_name:%s code:%d value:%d.\n",
+            device->devname, code, event->value);
+        return;
+    }
+
+    struct libevdev *evdev = device->evdev;
+    evdev_device_check_abs_axis_range(device, event->code, event->value);
+    const struct input_absinfo *absinfo_raw = libevdev_get_abs_info(evdev, event->code);
+    absinfo->code = event->code;
+    absinfo->value = event->value;
+    absinfo->minimum = absinfo_raw->minimum;
+    absinfo->maximum = absinfo_raw->maximum;
+    absinfo->fuzz = absinfo_raw->fuzz;
+    absinfo->flat = absinfo_raw->flat;
+    absinfo->resolution = absinfo_raw->resolution;
+    absinfo->standardValue = get_joystick_abs_standard_value(absinfo);
+}
+
+static void
+joystick_notify_absolute_event(struct joystick_dispatch* pJoystick,
+    struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (pJoystick == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    joystick_get_one_abs_info(pJoystick, device, event, event->code);
+}
+
+static void
+joystick_flush(struct joystick_dispatch* joystick_dispatch, struct evdev_device* device, uint64_t time)
+{
+    if (joystick_dispatch == NULL || device == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->axis_value_mask != 0) {
+        joystick_notify_axis(device, time);
+        joystick_reset_axis_value_mask(joystick_dispatch);
+    }
+}
+
+static void
+joystick_process(struct evdev_dispatch* dispatch, struct evdev_device* device,
+    struct input_event* event, uint64_t time)
+{
+    if (dispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    switch (event->type) {
+    case EV_ABS: {
+        joystick_notify_absolute_event(joystick_dispatch, device, event, time);
+    }
+    break;
+    case EV_KEY: {
+        joystick_notify_key_event(device, event, time);
+    }
+    break;
+    case EV_SYN: {
+        joystick_flush(joystick_dispatch, device, time);
+    }
+    break;
+    case EV_MSC:
+    /* ignore do not process */
+    break;
+    case EV_REL:
+    case EV_SW:
+    case EV_LED:
+    case EV_SND:
+    case EV_REP:
+    case EV_FF:
+    case EV_PWR:
+    case EV_FF_STATUS:
+    case EV_MAX:
+    case EV_CNT:
+    default:
+        libinput_log_printf("unsupported joystick event type: %d, devname: %s.\n", event->type, device->devname);
+    break;
+    }
+}
+
+static void joystick_suspend(struct evdev_dispatch* dispatch, struct evdev_device* device)
+{
+    if (dispatch == NULL || device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+   joystick_flush(joystick_dispatch, device, 0);
+}
+
+static void
+joystick_destroy(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (dispatch == NULL) {
+        return;
+    }
+
+    free(joystick_dispatch);
+}
+
+static void
+joystick_device_added(struct evdev_device* device,
+    struct evdev_device* added_device)
+{
+    if (device == NULL || added_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    bool is_joystick = false;
+    if (libinput_device_get_device_group(&device->base) !=
+        libinput_device_get_device_group(&added_device->base)) {
+        return;
+    }
+    is_joystick = evdev_device_has_capability(added_device,
+        LIBINPUT_DEVICE_CAP_JOYSTICK);
+
+    if (is_joystick) {
+        evdev_log_debug(device,
+            "joystick: activated for %s<->%s\n",
+            device->devname,
+            added_device->devname);
+        joystick_dispatch->device = added_device;
+    }
+}
+
+static void
+joystick_device_removed(struct evdev_device* device,
+    struct evdev_device* removed_device)
+{
+    if (device == NULL || removed_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->device == removed_device) {
+        joystick_dispatch->device = NULL;
+    }
+}
+
+static struct evdev_dispatch_interface joystick_interface = {
+    .process = joystick_process,
+    .suspend = joystick_suspend,
+    .remove = NULL,
+    .destroy = joystick_destroy,
+    .device_added = joystick_device_added,
+    .device_removed = joystick_device_removed,
+    .device_suspended = NULL,
+    .device_resumed = NULL,
+    .post_added = NULL,
+    .touch_arbitration_toggle = NULL,
+    .touch_arbitration_update_rect = NULL,
+    .get_switch_state = NULL,
+};
+
+static enum libinput_config_status
+joystick_sendevents_set_mode(struct libinput_device* device,
+    enum libinput_config_send_events_mode mode)
+{
+    if (device == NULL)     {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* joystick_dispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || joystick_dispatch == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if (mode == joystick_dispatch->sendevents.current_mode) {
+        return LIBINPUT_CONFIG_STATUS_SUCCESS;
+    }
+
+    switch (mode) {
+    case LIBINPUT_CONFIG_SEND_EVENTS_ENABLED:
+        break;
+    case LIBINPUT_CONFIG_SEND_EVENTS_DISABLED:
+        joystick_suspend(ev_device->dispatch, ev_device);
+        break;
+    default:
+        return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+    }
+
+    joystick_dispatch->sendevents.current_mode = mode;
+
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+static uint32_t
+joystick_sendevents_get_modes(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_mode(struct libinput_device* device)
+{
+    if (device == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* pDispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pDispatch == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    return pDispatch->sendevents.current_mode;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_default_mode(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+#ifdef _DEBUG
+void printf_joystick_absinfo(const char *abs_name, struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    printf("%s: code: %d, value: %d, minimum: %d, maximum: %d, fuzz: %d, flat: %d, resolution: %d, standardValue: %f\n",
+        abs_name,
+        absinfo->code,
+        absinfo->value,
+        absinfo->minimum,
+        absinfo->maximum,
+        absinfo->fuzz,
+        absinfo->flat,
+        absinfo->resolution,
+        absinfo->standardValue
+        );
+}
+
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis *p)
+{
+    printf("JOYSTICK:\n"
+        "type: %d, device: %p, type: %d, time: 0x%x\n",
+        p->base.type,
+        p->base.device,
+        p->type,
+        p->time);
+    printf_joystick_absinfo("abs_throttle", &p->abs_throttle);
+    printf_joystick_absinfo("abs_hat0x", &p->abs_hat0x);
+    printf_joystick_absinfo("abs_hat0y", &p->abs_hat0y);
+    printf_joystick_absinfo("abs_x", &p->abs_x);
+	printf_joystick_absinfo("abs_y", &p->abs_y);
+	printf_joystick_absinfo("abs_z", &p->abs_z);
+	printf_joystick_absinfo("abs_rx", &p->abs_rx);
+	printf_joystick_absinfo("abs_ry", &p->abs_ry);
+    printf_joystick_absinfo("abs_rz", &p->abs_rz);
+}
+#endif // _DEBUG
+
+/**
+ * @brief 初始化joystick_dispatch
+ * @param joystick
+ * @param device
+ * @return bool true - 成功, false - 失败
+*/
+bool
+joystick_init(struct joystick_dispatch* pJoystick, struct evdev_device* device)
+{
+    if (pJoystick == NULL || device == NULL) {
+        return false;
+    }
+
+    pJoystick->base.dispatch_type = DISPATCH_JOYSTICK;
+    pJoystick->base.interface = &joystick_interface;
+    pJoystick->device = device;
+
+    return true;
+}
+
+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device)
+{
+    if (device == NULL) {
+        return NULL;
+    }
+
+    struct joystick_dispatch* joystick = {0};
+    joystick = zalloc(sizeof * joystick);
+
+    if (joystick_init(joystick, device) != true) {
+        joystick_destroy(&joystick->base);
+        joystick = NULL;
+        return NULL;
+    }
+
+    device->base.config.sendevents = &joystick->sendevents.config;
+    joystick->sendevents.current_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    joystick->sendevents.config.get_modes = joystick_sendevents_get_modes;
+    joystick->sendevents.config.set_mode = joystick_sendevents_set_mode;
+    joystick->sendevents.config.get_mode = joystick_sendevents_get_mode;
+    joystick->sendevents.config.get_default_mode = joystick_sendevents_get_default_mode;
+
+    return &joystick->base;
+}
+
diff -Naur old/src/evdev-joystick.h new/src/evdev-joystick.h
--- old/src/evdev-joystick.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef LIBINPUT_EVDEV_JOYSTICK_H
+#define LIBINPUT_EVDEV_JOYSTICK_H
+
+#include "evdev.h"
+#include "libinput-private.h"
+
+struct joystick_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device* device;
+	uint32_t axis_value_mask;
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+};
+
+struct libinput_event_joystick_button {
+	struct libinput_event base;
+	uint32_t type;
+	uint64_t time;
+	uint32_t key;
+	uint32_t seat_key_count;
+	enum libinput_key_state state;
+	int value;
+};
+
+struct libinput_event_joystick_axis {
+	struct libinput_event base;
+    uint32_t type;
+	uint64_t time;
+	uint32_t axis_value_mask;
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+};
+
+#ifdef _DEBUG
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis* p);
+#endif // _DEBUG
+
+/**
+ * @brief 创建evdev_dispatch结构体
+ * @param device
+ * @return struct evdev_dispatch*
+*/
+struct evdev_dispatch* evdev_joystick_create(struct evdev_device* device);
+
+#endif
diff -Naur old/src/evdev-mt-touchpad-gestures.c new/src/evdev-mt-touchpad-gestures.c
--- old/src/evdev-mt-touchpad-gestures.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-gestures.c	2021-01-01 00:00:00.000000000 +0800
@@ -80,6 +80,37 @@
 }

 static void
+tp_get_raw_touches(struct tp_dispatch *tp, struct sloted_coords_info *raw_touches)
+{
+	struct tp_touch *t;
+	unsigned int i;
+	raw_touches->active_count = 0;
+
+	if (tp->num_slots > MAX_SOLTED_COORDS_NUM) {
+		evdev_log_bug_libinput(tp->device,
+				       "in %s, num_slots: %d, more than %d\n",
+				       __func__, tp->num_slots, MAX_SOLTED_COORDS_NUM);
+	}
+	const unsigned int num_slots = (tp->num_slots > MAX_SOLTED_COORDS_NUM) ? MAX_SOLTED_COORDS_NUM : tp->num_slots;
+
+	for (i = 0; i < num_slots; i++) {
+		t = &tp->touches[i];
+
+		if (!tp_touch_active_for_gesture(tp, t))
+			continue;
+
+		if (t->dirty) {
+			struct device_coords d;
+			d = tp_get_delta(t);
+			raw_touches->coords[i].x = d.x;
+			raw_touches->coords[i].y = d.y;
+		}
+		raw_touches->coords[i].is_active = true;
+		raw_touches->active_count++;
+	}
+}
+
+static void
 tp_gesture_init_scroll(struct tp_dispatch *tp)
 {
 	struct phys_coords zero = {0.0, 0.0};
@@ -131,7 +162,7 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 				     tp->gesture.finger_count,
-				     &zero, &zero);
+				     &zero, &zero, NULL);
 		break;
 	}

@@ -630,10 +661,12 @@
 tp_gesture_handle_state_swipe(struct tp_dispatch *tp, uint64_t time)
 {
 	struct device_float_coords raw;
+	struct sloted_coords_info raw_touches = {};
 	struct normalized_coords delta, unaccel;

 	raw = tp_get_average_touches_delta(tp);
 	delta = tp_filter_motion(tp, &raw, time);
+	tp_get_raw_touches(tp, &raw_touches);

 	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
 		unaccel = tp_normalize_delta(tp, raw);
@@ -641,7 +674,7 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
 				     tp->gesture.finger_count,
-				     &delta, &unaccel);
+				     &delta, &unaccel, &raw_touches);
 	}

 	return GESTURE_STATE_SWIPE;
diff -Naur old/src/evdev-mt-touchpad-tap.c new/src/evdev-mt-touchpad-tap.c
--- old/src/evdev-mt-touchpad-tap.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-tap.c	2022-12-12 19:49:27.376953599 +0800
@@ -72,6 +72,7 @@
 	CASE_RETURN_STRING(TAP_STATE_DRAGGING_OR_TAP);
 	CASE_RETURN_STRING(TAP_STATE_DRAGGING_2);
 	CASE_RETURN_STRING(TAP_STATE_DEAD);
+	CASE_RETURN_STRING(TAP_STATE_HOLDING);
 	}
 	return NULL;
 }
@@ -122,6 +123,10 @@

 	button = button_map[tp->tap.map][nfingers - 1];

+	if (tp->device->key_count[button] == 0 &&
+		state == LIBINPUT_BUTTON_STATE_RELEASED)
+		return;
+
 	if (state == LIBINPUT_BUTTON_STATE_PRESSED)
 		tp->tap.buttons_pressed |= (1 << nfingers);
 	else
@@ -226,6 +231,10 @@
 	case TAP_EVENT_TIMEOUT:
 		tp->tap.state = TAP_STATE_HOLD;
 		tp_tap_clear_timer(tp);
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_PRESSED);
 		break;
 	case TAP_EVENT_BUTTON:
 		tp->tap.state = TAP_STATE_DEAD;
@@ -262,8 +271,48 @@
 		tp->tap.state = TAP_STATE_IDLE;
 		break;
 	case TAP_EVENT_MOTION:
+		tp->tap.state = TAP_STATE_HOLDING;
+		break;
+	case TAP_EVENT_TIMEOUT:
+		break;
+	case TAP_EVENT_BUTTON:
+		tp->tap.state = TAP_STATE_DEAD;
+		break;
+	case TAP_EVENT_THUMB:
+		tp->tap.state = TAP_STATE_IDLE;
+		t->tap.is_thumb = true;
+		tp->tap.nfingers_down--;
+		t->tap.state = TAP_TOUCH_STATE_DEAD;
+		break;
+	case TAP_EVENT_PALM:
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	case TAP_EVENT_PALM_UP:
+		break;
+	}
+	if ((tp->tap.state != TAP_STATE_HOLDING) && (tp->tap.state != TAP_STATE_HOLD)) {
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_RELEASED);
+	}
+}
+
+static void
+tp_tap_holding_handle_event(struct tp_dispatch *tp,
+			    struct tp_touch *t,
+			    enum tap_event event, uint64_t time)
+{
+
+	switch (event) {
+	case TAP_EVENT_TOUCH:
 		tp_tap_move_to_dead(tp, t);
 		break;
+	case TAP_EVENT_RELEASE:
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	case TAP_EVENT_MOTION:
+		break;
 	case TAP_EVENT_TIMEOUT:
 		break;
 	case TAP_EVENT_BUTTON:
@@ -281,6 +330,12 @@
 	case TAP_EVENT_PALM_UP:
 		break;
 	}
+	if (tp->tap.state != TAP_STATE_HOLDING) {
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_RELEASED);
+    }
 }

 static void
@@ -796,6 +851,9 @@
 	case TAP_STATE_DEAD:
 		tp_tap_dead_handle_event(tp, t, event, time);
 		break;
+	case TAP_STATE_HOLDING:
+		tp_tap_holding_handle_event(tp, t, event, time);
+		break;
 	}

 	if (tp->tap.state == TAP_STATE_IDLE || tp->tap.state == TAP_STATE_DEAD)
@@ -1154,7 +1212,7 @@
 static inline enum libinput_config_drag_state
 tp_drag_default(struct evdev_device *device)
 {
-	return LIBINPUT_CONFIG_DRAG_ENABLED;
+	return LIBINPUT_CONFIG_DRAG_DISABLED;
 }
 
 static enum libinput_config_drag_state
@@ -1295,3 +1353,63 @@
 		return false;
 	}
 }
+
+void
+tp_tap_original_down(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	struct evdev_device *device = tp->device;
+	int slot_idx = tp->slot;
+	int seat_slot = t->seat_slot;
+	int32_t pressure = t->pressure;
+	int tool_type = t->tool_type;
+	struct device_coords point;
+	struct device_coord_rect rect;
+	point = t->point;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	rect = t->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touchpad_notify_touch_down(base, time, slot_idx, seat_slot, pressure, tool_type, axis, &point, &rect);
+}
+
+void
+tp_tap_original_up(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	int slot_idx = tp->slot;
+	int seat_slot = t->seat_slot;
+	t->seat_slot = -1;
+	int tool_type = t->tool_type;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	touchpad_notify_touch_up(base, time, slot_idx, seat_slot, tool_type, axis);
+}
+
+void
+tp_tap_original_motion(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	struct evdev_device *device = tp->device;
+	int seat_slot = t->seat_slot;
+	int slot_idx = tp->slot;
+	int32_t pressure = t->pressure;
+	int tool_type = t->tool_type;
+	struct device_coords point;
+    struct device_coord_rect rect;
+	point = t->point;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	rect = t->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touchpad_notify_touch_motion(base, time, slot_idx, seat_slot, pressure, tool_type, axis, &point, &rect);
+}
\ No newline at end of file
diff -Naur old/src/evdev-mt-touchpad.c new/src/evdev-mt-touchpad.c
--- old/src/evdev-mt-touchpad.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad.c	2021-01-01 00:00:00.000000000 +0800
@@ -308,6 +308,35 @@
 }

 static inline void
+tp_tool_key_set(struct tp_dispatch *tp,
+		   unsigned int code,
+		   bool is_press)
+{
+	unsigned int shift = 0;
+
+	switch (code) {
+		case BTN_TOOL_PEN:
+		case BTN_TOOL_RUBBER:
+		case BTN_TOOL_BRUSH:
+		case BTN_TOOL_PENCIL:
+		case BTN_TOOL_AIRBRUSH:
+		case BTN_TOOL_FINGER:
+		case BTN_TOOL_MOUSE:
+		case BTN_TOOL_LENS:
+			shift = code - BTN_TOOL_PEN;
+			break;
+		default:
+			return;
+	}
+
+	if (is_press) {
+		tp->tool_touches |= 0x1 << shift;
+	} else {
+		tp->tool_touches &= ~(0x1 << shift);
+	}
+}
+
+static inline void
 tp_new_touch(struct tp_dispatch *tp, struct tp_touch *t, uint64_t time)
 {
 	if (t->state == TOUCH_BEGIN ||
@@ -341,6 +370,7 @@
 	t->speed.last_speed = 0;
 	t->speed.exceeded_count = 0;
 	t->hysteresis.x_motion_history = 0;
+	t->seat_slot = -1;
 	tp->queued |= TOUCHPAD_EVENT_MOTION;
 }

@@ -496,6 +526,81 @@
 	return absinfo->maximum - (value - absinfo->minimum);
 }

+void tp_ext_post_event(struct tp_dispatch* dispatch, bool is_up, uint64_t time)
+{
+	struct tp_touch * t = tp_current_touch(dispatch);
+	int seat_slot = t->seat_slot;
+	if (is_up) {
+		if (seat_slot == -1) {
+			return;
+		}
+
+		dispatch->orginal.active_slot_count--;
+		if (dispatch->orginal.active_slot_count < 0) {
+			dispatch->orginal.active_slot_count = 0;
+		}
+
+		if (dispatch->orginal.active_slot_count == 0) {
+			dispatch->orginal.seat_slot_id = 0;
+		}
+
+		tp_tap_original_up(dispatch, t, time);
+		return;
+	}
+
+	if (seat_slot == -1) {
+		t->seat_slot = dispatch->orginal.seat_slot_id++;
+		dispatch->orginal.active_slot_count++;
+
+		tp_tap_original_down(dispatch, t, time);
+		return;
+	}
+
+	tp_tap_original_motion(dispatch, t, time);
+}
+
+void tp_ext_on_xy_update(struct tp_dispatch* dispatch)
+{
+	dispatch->orginal.xy_updated = true;
+}
+
+void tp_ext_on_mt_slot(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
+void tp_ext_before_new_touch(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
+void tp_ext_before_delete_touch(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+	};
+
+	tp_ext_post_event(dispatch, true, time);
+}
+
+void tp_ext_on_sync(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
 static void
 tp_process_absolute(struct tp_dispatch *tp,
 		    const struct input_event *e,
@@ -505,6 +610,7 @@

 	switch(e->code) {
 	case ABS_MT_POSITION_X:
+		tp_ext_on_xy_update(tp);
 		evdev_device_check_abs_axis_range(tp->device,
 						  e->code,
 						  e->value);
@@ -514,6 +620,7 @@
 		tp->queued |= TOUCHPAD_EVENT_MOTION;
 		break;
 	case ABS_MT_POSITION_Y:
+		tp_ext_on_xy_update(tp);
 		evdev_device_check_abs_axis_range(tp->device,
 						  e->code,
 						  e->value);
@@ -523,14 +630,17 @@
 		tp->queued |= TOUCHPAD_EVENT_MOTION;
 		break;
 	case ABS_MT_SLOT:
+		tp_ext_on_mt_slot(tp, time);
 		tp->slot = e->value;
 		break;
 	case ABS_MT_TRACKING_ID:
 		if (e->value != -1) {
+			tp_ext_before_new_touch(tp, time);
 			tp->nactive_slots += 1;
 			tp_new_touch(tp, t, time);
 		} else {
 			assert(tp->nactive_slots >= 1);
+			tp_ext_before_delete_touch(tp, time);
 			tp->nactive_slots -= 1;
 			tp_end_sequence(tp, t, time);
 		}
@@ -543,6 +653,7 @@
 		break;
 	case ABS_MT_TOOL_TYPE:
 		t->is_tool_palm = e->value == MT_TOOL_PALM;
+		t->tool_type = e->value;
 		t->time = time;
 		t->dirty = true;
 		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
@@ -557,6 +668,26 @@
 		t->dirty = true;
 		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
 		break;
+	case ABS_MT_WIDTH_MAJOR:
+		t->tool_rect.w = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_WIDTH_MINOR:
+		t->tool_rect.h = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_TOOL_X:
+		t->tool_rect.x = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_TOOL_Y:
+		t->tool_rect.y = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
 	}
 }

@@ -772,6 +903,20 @@
 			tp_process_trackpoint_button(tp, e, time);
 			break;
 	}
+
+	switch (e->code) {
+		case BTN_TOOL_PEN:
+		case BTN_TOOL_RUBBER:
+		case BTN_TOOL_BRUSH:
+		case BTN_TOOL_PENCIL:
+		case BTN_TOOL_AIRBRUSH:
+		case BTN_TOOL_FINGER:
+		case BTN_TOOL_MOUSE:
+		case BTN_TOOL_LENS:
+			tp_tool_key_set(tp, e->code, !!e->value);
+		default:
+			break;
+	}
 }

 static void
@@ -1951,6 +2096,7 @@
 		tp_process_msc(tp, e, time);
 		break;
 	case EV_SYN:
+		tp_ext_on_sync(tp, time);
 		tp_handle_state(tp, time);
 #if 0
 		tp_debug_touch_state(tp, device);
@@ -2843,6 +2989,8 @@
 	t->tp = tp;
 	t->has_ended = true;
 	t->index = index;
+	t->seat_slot = -1;
+	t->tool_type = -1;
 }

 static inline void
@@ -3660,6 +3808,10 @@
 	if (tp->gesture.enabled)
 		device->seat_caps |= EVDEV_DEVICE_GESTURE;

+	tp->orginal.seat_slot_id = 0;
+	tp->orginal.active_slot_count = 0;
+	tp->orginal.xy_updated = 0;
+
 	return true;
 }

@@ -3843,6 +3995,14 @@

 	tp = zalloc(sizeof *tp);

+	const struct input_absinfo* absInfo = device->is_mt ? libevdev_get_abs_info(device->evdev, ABS_MT_PRESSURE)
+		: libevdev_get_abs_info(device->evdev, ABS_PRESSURE);
+	if (absInfo == NULL) {
+		device->pressureMax = 0.0;
+	} else {
+		device->pressureMax = absInfo->maximum;
+	}
+
 	if (!tp_init(tp, device)) {
 		tp_interface_destroy(&tp->base);
 		return NULL;
@@ -3860,3 +4020,27 @@

 	return &tp->base;
 }
+
+bool
+evdev_device_touchpad_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType)
+{
+	struct tp_dispatch *tp = tp_dispatch(device->dispatch);
+
+	unsigned int shift = 0;
+	switch (btnToolType) {
+	case BTN_TOOL_PEN:
+	case BTN_TOOL_RUBBER:
+	case BTN_TOOL_BRUSH:
+	case BTN_TOOL_PENCIL:
+	case BTN_TOOL_AIRBRUSH:
+	case BTN_TOOL_FINGER:
+	case BTN_TOOL_MOUSE:
+	case BTN_TOOL_LENS:
+		shift = btnToolType - BTN_TOOL_PEN;
+		break;
+	default:
+		return false;
+	}
+
+	return (tp->tool_touches >> shift) & 0x1;
+}
\ No newline at end of file
diff -Naur old/src/evdev-mt-touchpad.h new/src/evdev-mt-touchpad.h
--- old/src/evdev-mt-touchpad.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad.h	2021-01-01 00:00:00.000000000 +0800
@@ -118,6 +118,7 @@
 	TAP_STATE_DRAGGING_WAIT,
 	TAP_STATE_DRAGGING_2,
 	TAP_STATE_DEAD, /**< finger count exceeded */
+	TAP_STATE_HOLDING,
 };

 enum tp_tap_touch_state {
@@ -176,10 +177,14 @@
 	int pressure;
 	bool is_tool_palm; /* MT_TOOL_PALM */
 	int major, minor;
+    struct device_coord_rect tool_rect;

 	bool was_down; /* if distance == 0, false for pure hovering
 			  touches */

+	int seat_slot;
+	int tool_type;
+
 	struct {
 		/* A quirk mostly used on Synaptics touchpads. In a
 		   transition to/from fake touches > num_slots, the current
@@ -294,6 +299,17 @@
 	 */
 	unsigned int fake_touches;

+	/* bit 0: BTN_TOOL_PEN
+	 * bit 1: BTN_TOOL_RUBBER
+	 * bit 2: BTN_TOOL_BRUSH
+	 * bit 3: BTN_TOOL_PENCIL
+	 * bit 4: BTN_TOOL_AIRBRUSH
+	 * bit 5: BTN_TOOL_FINGER
+	 * bit 6: BTN_TOOL_MOUSE
+	 * bit 7: BTN_TOOL_LENS
+	 */
+	unsigned int tool_touches;
+
 	struct {
 		bool detection_disabled;
 		struct ratelimit warning;
@@ -513,6 +529,12 @@
 		struct evdev_device *tablet_device;
 		bool tablet_left_handed_state;
 	} left_handed;
+
+	struct {
+		int seat_slot_id;
+		int active_slot_count;
+		int xy_updated;
+	} orginal;
 };

 static inline struct tp_dispatch*
@@ -730,4 +752,19 @@
 void
 tp_init_thumb(struct tp_dispatch *tp);

+void
+tp_tap_original_down(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_tap_original_up(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_tap_original_motion(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
 #endif
diff -Naur old/src/evdev-tablet.c new/src/evdev-tablet.c
--- old/src/evdev-tablet.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet.c	2021-01-01 00:00:00.000000000 +0800
@@ -219,6 +219,7 @@
 	case ABS_TILT_Y:
 	case ABS_DISTANCE:
 	case ABS_WHEEL:
+	case ABS_MT_TOOL_TYPE:
 		axis = evcode_to_axis(e->code);
 		if (axis == LIBINPUT_TABLET_TOOL_AXIS_NONE) {
 			evdev_log_bug_libinput(device,
@@ -230,7 +231,6 @@
 		tablet->prev_value[axis] = tablet->current_value[axis];
 		if (tablet_filter_axis_fuzz(tablet, device, e, axis))
 			break;
-
 		tablet->current_value[axis] = e->value;
 		set_bit(tablet->changed_axes, axis);
 		tablet_set_status(tablet, TABLET_AXES_UPDATED);
@@ -1170,6 +1170,7 @@
 			.serial = serial,
 			.tool_id = tool_id,
 			.refcount = 1,
+			.mt_tool_type = tablet->current_value[LIBINPUT_TABLET_TOOL_AXIS_TYPE],
 		};

 		tool_set_pressure_thresholds(tablet, tool);
@@ -2117,11 +2118,11 @@
 {
 	struct tablet_dispatch *tablet = tablet_dispatch(device->dispatch);
 	bool is_touchscreen, is_ext_touchpad;
-
+/*
 	if (libinput_device_get_device_group(&device->base) !=
 	    libinput_device_get_device_group(&added_device->base))
 		return;
-
+*/
 	is_touchscreen = evdev_device_has_capability(added_device,
 						     LIBINPUT_DEVICE_CAP_TOUCH);
 	is_ext_touchpad = evdev_device_has_capability(added_device,
@@ -2368,6 +2369,34 @@
 	return true;
 }

+static void
+tablet_reset_abs_resolution(struct evdev_device *device)
+{
+    if (!device->abs.is_fake_resolution) {
+        return;
+    }
+    struct libevdev *evdev = device->evdev;
+    const struct input_absinfo *absy;
+    const struct input_absinfo *absx;
+    size_t widthmm = 271;
+    size_t heightmm = 170;
+    size_t xres = 0;
+    size_t yres = 0;
+
+    absx = libevdev_get_abs_info(evdev, ABS_X);
+    absy = libevdev_get_abs_info(evdev, ABS_Y);
+    xres = (absx->maximum - absx->minimum) / widthmm;
+    yres = (absy->maximum - absy->minimum) / heightmm;
+    if (xres == 0 || yres == 0) {
+        return;
+    }
+    libevdev_set_abs_resolution(evdev, ABS_X, xres);
+    libevdev_set_abs_resolution(evdev, ABS_Y, yres);
+    device->abs.is_fake_resolution = false;
+    libinput_log_printf("\t\tdevice:%s no resolution or size hints, assuming a size of %dx%d mm\n",
+        device->devname, widthmm, heightmm);
+}
+
 static int
 tablet_init(struct tablet_dispatch *tablet,
 	    struct evdev_device *device)
@@ -2382,6 +2411,7 @@
 	tablet->status = TABLET_NONE;
 	tablet->current_tool.type = LIBINPUT_TOOL_NONE;
 	list_init(&tablet->tool_list);
+    tablet_reset_abs_resolution(device);

 	if (tablet_reject_device(device))
 		return -1;
diff -Naur old/src/evdev-tablet.h new/src/evdev-tablet.h
--- old/src/evdev-tablet.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet.h	2021-01-01 00:00:00.000000000 +0800
@@ -151,6 +151,9 @@
 	case ABS_WHEEL:
 		axis = LIBINPUT_TABLET_TOOL_AXIS_SLIDER;
 		break;
+	case ABS_MT_TOOL_TYPE:
+		axis = LIBINPUT_TABLET_TOOL_AXIS_TYPE;
+		break;
 	default:
 		axis = LIBINPUT_TABLET_TOOL_AXIS_NONE;
 		break;
@@ -209,6 +212,9 @@
 	case LIBINPUT_TABLET_TOOL_AXIS_SIZE_MAJOR:
 		evcode = ABS_MT_TOUCH_MAJOR;
 		break;
+	case LIBINPUT_TABLET_TOOL_AXIS_TYPE:
+		evcode = ABS_MT_TOOL_TYPE;
+		break;
 	case LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR:
 		evcode = ABS_MT_TOUCH_MINOR;
 		break;
diff -Naur old/src/evdev.c new/src/evdev.c
--- old/src/evdev.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev.c	2021-01-01 00:00:00.000000000 +0800
@@ -54,25 +54,7 @@
 #define DEFAULT_BUTTON_SCROLL_TIMEOUT ms2us(200)
 #define MAX_RETRY_OPEN_DEVICE_COUNT 10

-enum evdev_device_udev_tags {
-        EVDEV_UDEV_TAG_INPUT		= bit(0),
-        EVDEV_UDEV_TAG_KEYBOARD		= bit(1),
-        EVDEV_UDEV_TAG_MOUSE		= bit(2),
-        EVDEV_UDEV_TAG_TOUCHPAD		= bit(3),
-        EVDEV_UDEV_TAG_TOUCHSCREEN	= bit(4),
-        EVDEV_UDEV_TAG_TABLET		= bit(5),
-        EVDEV_UDEV_TAG_JOYSTICK		= bit(6),
-        EVDEV_UDEV_TAG_ACCELEROMETER	= bit(7),
-        EVDEV_UDEV_TAG_TABLET_PAD	= bit(8),
-        EVDEV_UDEV_TAG_POINTINGSTICK	= bit(9),
-        EVDEV_UDEV_TAG_TRACKBALL	= bit(10),
-        EVDEV_UDEV_TAG_SWITCH		= bit(11),
-};

-struct evdev_udev_tag_match {
-	const char *name;
-	enum evdev_device_udev_tags tag;
-};

 static const struct evdev_udev_tag_match evdev_udev_tag_matches[] = {
 	{"ID_INPUT",			EVDEV_UDEV_TAG_INPUT},
@@ -341,6 +323,17 @@
 }

 void
+evdev_transform_absolute_rect(struct evdev_device *device,
+			 struct device_coord_rect *rect)
+{
+	if (!device->abs.apply_calibration)
+		return;
+
+	matrix_mult_vec(&device->abs.calibration, &rect->x, &rect->y);
+	matrix_mult_vec(&device->abs.calibration, &rect->w, &rect->h);
+}
+
+void
 evdev_transform_relative(struct evdev_device *device,
 			 struct device_coords *point)
 {
@@ -356,6 +349,9 @@
 static inline double
 scale_axis(const struct input_absinfo *absinfo, double val, double to_range)
 {
+	if (absinfo->maximum < absinfo->minimum) {
+		return 0.0;
+	}
 	return (val - absinfo->minimum) * to_range /
 		(absinfo->maximum - absinfo->minimum + 1);
 }
@@ -1771,6 +1767,9 @@
 	libevdev_disable_event_code(evdev, EV_ABS, REL_Z);
 }

+static enum evdev_device_udev_tags
+update_device_capability(struct evdev_device *device);
+
 static struct evdev_dispatch *
 evdev_configure_device(struct evdev_device *device)
 {
@@ -1780,11 +1779,17 @@
 	struct evdev_dispatch *dispatch;

 	udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    libinput_log_printf("----evdev_configure_device  tagged as supported input device---- %d \r\n", udev_tags);

 	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
 	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
+		udev_tags = update_device_capability(device);
+	}
+	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
+	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
 		evdev_log_info(device,
 			       "not tagged as supported input device\n");
+        libinput_log_printf("----evdev_configure_device not tagged as supported input device---- \r\n");
 		return NULL;
 	}

@@ -1812,12 +1817,6 @@
 		evdev_disable_accelerometer_axes(device);
 	}

-	if (udev_tags == (EVDEV_UDEV_TAG_INPUT|EVDEV_UDEV_TAG_JOYSTICK)) {
-		evdev_log_info(device,
-			       "device is a joystick, ignoring\n");
-		return NULL;
-	}
-
 	if (evdev_reject_device(device)) {
 		evdev_log_info(device, "was rejected\n");
 		return NULL;
@@ -1833,8 +1832,16 @@
 			udev_tags &= ~EVDEV_UDEV_TAG_TOUCHSCREEN;
 	}

+    if (udev_tags & EVDEV_UDEV_TAG_JOYSTICK) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_JOYSTICK_BULID-- \r\n");
+        dispatch = evdev_joystick_create(device);
+        device->seat_caps |= EVDEV_DEVICE_JOYSTICK;
+		return dispatch;
+    }
+
 	if (evdev_device_has_model_quirk(device,
 					 QUIRK_MODEL_DELL_CANVAS_TOTEM)) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOTEM_BULID-- \r\n");
 		dispatch = evdev_totem_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a totem\n");
@@ -1850,12 +1857,14 @@

 	/* libwacom assigns tablet _and_ tablet_pad to the pad devices */
 	if (udev_tags & EVDEV_UDEV_TAG_TABLET_PAD) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_PAD_BULID-- \r\n");
 		dispatch = evdev_tablet_pad_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET_PAD;
 		evdev_log_info(device, "device is a tablet pad\n");
 		return dispatch;

 	} else if ((udev_tags & tablet_tags) == EVDEV_UDEV_TAG_TABLET) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_BULID-- \r\n");
 		dispatch = evdev_tablet_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a tablet\n");
@@ -1863,6 +1872,7 @@
 	}

 	if (udev_tags & EVDEV_UDEV_TAG_TOUCHPAD) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOUCHPAD_BULID-- \r\n");
 		if (udev_tags & EVDEV_UDEV_TAG_TABLET)
 			evdev_tag_tablet_touchpad(device);
 		/* whether velocity should be averaged, false by default */
@@ -2292,6 +2302,18 @@
 }

 unsigned int
+evdev_device_get_id_bustype(struct evdev_device *device)
+{
+	return libevdev_get_id_bustype(device->evdev);
+}
+
+unsigned int
+evdev_device_get_id_version(struct evdev_device *device)
+{
+	return libevdev_get_id_version(device->evdev);
+}
+
+unsigned int
 evdev_device_get_id_product(struct evdev_device *device)
 {
 	return libevdev_get_id_product(device->evdev);
@@ -2309,6 +2331,33 @@
 	return udev_device_ref(device->udev_device);
 }

+enum evdev_device_udev_tags
+	evdev_device_get_udev_device_tags(struct evdev_device* device)
+{
+    enum evdev_device_udev_tags udev_tags;
+    udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    return udev_tags;
+}
+
+int
+evdev_has_event_type(struct evdev_device *device, unsigned int type)
+{
+    return libevdev_has_event_type(device->evdev, type);
+}
+
+int
+evdev_get_event_value(struct evdev_device *device, unsigned int type, unsigned int code)
+{
+    return libevdev_get_event_value(device->evdev, type, code);
+}
+
+int
+evdev_kernel_set_led_value(struct evdev_device *device, unsigned int code, unsigned int state)
+{
+    enum libevdev_led_value value = (state == 0 ? LIBEVDEV_LED_OFF : LIBEVDEV_LED_ON);
+    return libevdev_kernel_set_led_value(device->evdev, code, value);
+}
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6])
@@ -2476,6 +2525,9 @@
 		return !!(device->seat_caps & EVDEV_DEVICE_TABLET_PAD);
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		return !!(device->seat_caps & EVDEV_DEVICE_SWITCH);
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+		return !!(device->seat_caps & EVDEV_DEVICE_JOYSTICK);
+
 	default:
 		return false;
 	}
@@ -2917,3 +2969,59 @@
 #endif
 	return has_left_handed;
 }
+
+static inline bool
+is_touchscreen(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_X) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_Y) &&
+			libevdev_has_property(evdev, INPUT_PROP_DIRECT));
+}
+
+static inline bool
+is_mouse(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_REL) &&
+			libevdev_has_event_code(evdev, EV_REL, REL_X) &&
+			libevdev_has_event_code(evdev, EV_REL, REL_Y));
+}
+
+static inline bool
+is_keyboard(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_KEY) &&
+			!libevdev_has_event_type(evdev, EV_ABS) &&
+			!libevdev_has_event_type(evdev, EV_REL));
+}
+
+static inline bool
+is_tablet_tool(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_KEY) &&
+			(libevdev_has_event_code(evdev, EV_KEY, BTN_TOOL_PEN) ||
+			 libevdev_has_event_code(evdev, EV_KEY, BTN_STYLUS)) &&
+			libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_X) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_Y));
+}
+
+static enum evdev_device_udev_tags
+update_device_capability(struct evdev_device *device)
+{
+    evdev_log_info(device, "update_device_capability() enter\n");
+	if (is_touchscreen(device->evdev)) {
+        return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TOUCHSCREEN);
+	}
+	if (is_mouse(device->evdev)) {
+        return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_MOUSE);
+	}
+	if (is_keyboard(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_KEYBOARD);
+	}
+	if (is_tablet_tool(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TABLET);
+	}
+	evdev_log_info(device, "update_device_capability() leave\n");
+    return 0;
+}
diff -Naur old/src/evdev.h new/src/evdev.h
--- old/src/evdev.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev.h	2021-01-01 00:00:00.000000000 +0800
@@ -61,6 +61,7 @@
 	EVDEV_DEVICE_TABLET_PAD		= bit(4),
 	EVDEV_DEVICE_GESTURE		= bit(5),
 	EVDEV_DEVICE_SWITCH		= bit(6),
+	EVDEV_DEVICE_JOYSTICK = bit(7),
 };

 enum evdev_device_tags {
@@ -76,6 +77,11 @@
 	EVDEV_TAG_TABLET_TOUCHPAD	= bit(9),
 };

+struct evdev_udev_tag_match {
+    const char* name;
+    enum evdev_device_udev_tags tag;
+};
+
 enum evdev_middlebutton_state {
 	MIDDLEBUTTON_IDLE,
 	MIDDLEBUTTON_LEFT_DOWN,
@@ -175,6 +181,7 @@
 	enum evdev_device_tags tags;
 	bool is_mt;
 	bool is_suspended;
+	int32_t pressureMax;
 	int dpi; /* HW resolution */
 	double trackpoint_multiplier; /* trackpoint constant multiplier */
 	bool use_velocity_averaging; /* whether averaging should be applied on velocity calculation */
@@ -353,6 +360,7 @@
 	DISPATCH_TABLET,
 	DISPATCH_TABLET_PAD,
 	DISPATCH_TOTEM,
+	DISPATCH_JOYSTICK,
 };

 struct evdev_dispatch {
@@ -406,6 +414,10 @@
 			 struct device_coords *point);

 void
+evdev_transform_absolute_rect(struct evdev_device *device,
+			 struct device_coord_rect *rect);
+
+void
 evdev_transform_relative(struct evdev_device *device,
 			 struct device_coords *point);

@@ -430,12 +442,19 @@
 evdev_device_init_pointer_acceleration(struct evdev_device *device,
 				       struct motion_filter *filter);

+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device);
+
+
 struct evdev_dispatch *
 evdev_touchpad_create(struct evdev_device *device);

 struct evdev_dispatch *
 evdev_mt_touchpad_create(struct evdev_device *device);

+bool
+evdev_device_touchpad_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType);
+
 struct evdev_dispatch *
 evdev_tablet_create(struct evdev_device *device);

@@ -473,6 +492,12 @@
 evdev_device_get_name(struct evdev_device *device);

 unsigned int
+evdev_device_get_id_bustype(struct evdev_device *device);
+
+unsigned int
+evdev_device_get_id_version(struct evdev_device *device);
+
+unsigned int
 evdev_device_get_id_product(struct evdev_device *device);

 unsigned int
@@ -481,6 +506,19 @@
 struct udev_device *
 evdev_device_get_udev_device(struct evdev_device *device);

+/**  @brief   获取设备类型 */
+enum evdev_device_udev_tags
+evdev_device_get_udev_device_tags(struct evdev_device* device);
+
+int
+evdev_has_event_type(struct evdev_device *device, unsigned int type);
+
+int
+evdev_get_event_value(struct evdev_device *device, unsigned int type, unsigned int code);
+
+int
+evdev_kernel_set_led_value(struct evdev_device *device, unsigned int code, unsigned int state);
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6]);
@@ -506,6 +544,9 @@
 int
 evdev_device_get_touch_count(struct evdev_device *device);

+bool
+evdev_device_touch_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType);
+
 int
 evdev_device_has_switch(struct evdev_device *device,
 			enum libinput_switch sw);
@@ -629,6 +670,9 @@
 static inline double
 evdev_convert_to_mm(const struct input_absinfo *absinfo, double v)
 {
+	if (absinfo->resolution  == 0){
+	    return 0.0;
+	}
 	double value = v - absinfo->minimum;
 	return value/absinfo->resolution;
 }
@@ -764,12 +808,15 @@

 	if (!is_logged(evdev_libinput_context(device), priority))
 		return;
-
+	const char *name = evdev_device_get_sysname(device);
+	if (strchr(name, '%') != NULL) {
+		return;
+	}
 	/* Anything info and above is user-visible, use the device name */
 	snprintf(buf,
 		 sizeof(buf),
 		 "%-7s - %s%s%s",
-		 evdev_device_get_sysname(device),
+		 name,
 		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  device->devname : "",
 		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  ": " : "",
 		 format);
@@ -1005,7 +1052,8 @@
 				   "Axis %#x value %d is outside expected range [%d, %d]\n"
 				   "See %sabsolute_coordinate_ranges.html for details\n",
 				   code, value, min, max,
-				   HTTP_DOC_LINK);
+				   "");
+				//HTTP_DOC_LINK);
 	}
 }

diff -Naur old/src/libinput-git-version.h new/src/libinput-git-version.h
--- old/src/libinput-git-version.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-git-version.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,3 @@
+#pragma once
+
+#define LIBINPUT_GIT_VERSION "@VCS_TAG@"
diff -Naur old/src/libinput-private.h new/src/libinput-private.h
--- old/src/libinput-private.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput-private.h	2021-01-01 00:00:00.000000000 +0800
@@ -48,6 +48,12 @@
 	int x, y;
 };

+/* Size of touch point region (major and minor axes of ellipse) */
+struct touch_axis {
+    int32_t major;
+    int32_t minor;
+};
+
 /*
  * A coordinate pair in device coordinates, capable of holding non discrete
  * values, this is necessary e.g. when device coordinates get averaged.
@@ -350,7 +356,8 @@
 	LIBINPUT_TABLET_TOOL_AXIS_SLIDER = 8,
 	LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL = 9,
 	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MAJOR = 10,
-	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR = 11,
+	LIBINPUT_TABLET_TOOL_AXIS_TYPE = 11,
+	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR = 12,
 };

 #define LIBINPUT_TABLET_TOOL_AXIS_MAX LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR
@@ -383,6 +390,7 @@
 	/* pressure_offset includes axis->minimum */
 	int pressure_offset;
 	bool has_pressure_offset;
+	int32_t mt_tool_type;
 };

 struct libinput_tablet_pad_mode_group {
@@ -569,20 +577,29 @@
 			uint64_t time,
 			int32_t slot,
 			int32_t seat_slot,
-			const struct device_coords *point);
+			int32_t pressure,
+            const struct touch_axis *axis,
+			const struct device_coords *point,
+			int32_t tool_type,
+			const struct device_coord_rect *tool_rect);

 void
 touch_notify_touch_motion(struct libinput_device *device,
 			  uint64_t time,
 			  int32_t slot,
 			  int32_t seat_slot,
-			  const struct device_coords *point);
+			  int32_t pressure,
+              const struct touch_axis *axis,
+			  const struct device_coords *point,
+			  int32_t tool_type,
+			  const struct device_coord_rect *tool_rect);

 void
 touch_notify_touch_up(struct libinput_device *device,
 		      uint64_t time,
 		      int32_t slot,
-		      int32_t seat_slot);
+		      int32_t seat_slot,
+		      int32_t tool_type);

 void
 touch_notify_touch_cancel(struct libinput_device *device,
@@ -595,12 +612,43 @@
 		   uint64_t time);

 void
+touchpad_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			int32_t pressure,
+			int32_t tool_type,
+			struct touch_axis axis,
+			const struct device_coords *point,
+			const struct device_coord_rect *tool_rect);
+
+void
+touchpad_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  int32_t pressure,
+			  int32_t tool_type,
+			  struct touch_axis axis,
+			  const struct device_coords *point,
+			  const struct device_coord_rect *tool_rect);
+
+void
+touchpad_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot,
+		      int32_t tool_type,
+			  struct touch_axis axis);
+
+void
 gesture_notify_swipe(struct libinput_device *device,
 		     uint64_t time,
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel);
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *raw_touches);

 void
 gesture_notify_swipe_end(struct libinput_device *device,
diff -Naur old/src/libinput-util.c new/src/libinput-util.c
--- old/src/libinput-util.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-util.c	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,102 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This list data structure is verbatim copy from wayland-util.h from the
+ * Wayland project; except that wl_ prefix has been removed.
+ */
+
+#include "libinput-util.h"
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+
+static FILE* p_log_fp = NULL;
+
+FILE *libinput_get_log_fp()
+{
+    if (p_log_fp == NULL) {
+        const char *pLogDir = getenv("LIBINPUT_LOG_DIR");
+        if (pLogDir == NULL) {
+            pLogDir = (char *)_LIBINPUT_LOG_DIR;
+        }
+
+        const int r = mkdir(pLogDir, 0755);
+        if (r < 0 && errno != EEXIST) {
+            const int saved_errno = errno;
+            printf("could not create %s, errno: %d\n", pLogDir, saved_errno);
+            return NULL;
+        }
+
+        const char *p_log_path = getenv("LIBINPUT_LOG_PATH");
+        if (p_log_path == NULL) {
+            p_log_path = (char *)_LIBINPUT_LOG_PATH;
+        }
+        p_log_fp = fopen(p_log_path, "w+");
+    }
+
+    return p_log_fp;
+}
+
+void libinput_log_printf(const char* fmt, ...)
+{
+    p_log_fp = libinput_get_log_fp();
+#ifdef HAVE_LIBINPUT_LOG_CONSOLE_ENABLE
+    char buf[1024] = {0};
+
+    va_list args;
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    buf[1024 - 1] = '\0';
+
+    printf("%s\n", buf);
+
+    if (p_log_fp != NULL) {
+        fputs(buf, p_log_fp);
+        fflush(p_log_fp);
+    }
+#else
+    if (p_log_fp != NULL) {
+        va_list args;
+        va_start(args, fmt);
+        vfprintf(p_log_fp, fmt, args);
+        va_end(args);
+        fflush(p_log_fp);
+    }
+#endif
+}
+
+uint64_t getMicrotime()
+{
+    struct timeval currentTime;
+    gettimeofday(&currentTime, NULL);
+    return currentTime.tv_sec * 1000000 + currentTime.tv_usec;
+}
+
+uint64_t getTranTime(struct input_event *event)
+{
+    return event->input_event_sec * 1000000 + event->input_event_usec;
+}
+#endif
diff -Naur old/src/libinput-util.h new/src/libinput-util.h
--- old/src/libinput-util.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput-util.h	2021-01-01 00:00:00.000000000 +0800
@@ -27,10 +27,9 @@

 #include "config.h"

-#ifdef NDEBUG
-#warning "libinput relies on assert(). #defining NDEBUG is not recommended"
-#endif
-
+//#ifdef NDEBUG
+//#warning "libinput relies on assert(). #defining NDEBUG is not recommended"
+//#endif

 #include "libinput.h"

@@ -57,6 +56,15 @@
 #define DEFAULT_MOUSE_DPI 1000
 #define DEFAULT_TRACKPOINT_SENSITIVITY 128

+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+void libinput_log_printf(const char* fmt, ...);
+uint64_t getMicrotime();
+uint64_t getTranTime(struct input_event *event);
+#else
+#define libinput_log_printf(fmt, ...)
+#endif
+
 #define trace(...) \
 	do { \
 	printf("%s() - \033[0;31m", __func__); \
diff -Naur old/src/libinput-version.h new/src/libinput-version.h
--- old/src/libinput-version.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-version.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright © 2013 Jonas Ådahl
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBINPUT_VERSION_H
+#define LIBINPUT_VERSION_H
+
+#define LIBINPUT_VERSION_MAJOR //@LIBINPUT_VERSION_MAJOR@
+#define LIBINPUT_VERSION_MINOR //@LIBINPUT_VERSION_MINOR@
+#define LIBINPUT_VERSION_MICRO //@LIBINPUT_VERSION_MICRO@
+#define LIBINPUT_VERSION "@LIBINPUT_VERSION@"
+
+#endif
diff -Naur old/src/libinput.c new/src/libinput.c
--- old/src/libinput.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput.c	2021-01-01 00:00:00.000000000 +0800
@@ -39,6 +39,7 @@
 #include "evdev.h"
 #include "timer.h"
 #include "quirks.h"
+#include "evdev-joystick.h"

 #define require_event_type(li_, type_, retval_, ...)	\
 	if (type_ == LIBINPUT_EVENT_NONE) abort(); \
@@ -123,6 +124,9 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_MOTION);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_CANCEL);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_FRAME);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_DOWN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_UP);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_MOTION);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_AXIS);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_TIP);
@@ -184,6 +188,10 @@
 	int32_t slot;
 	int32_t seat_slot;
 	struct device_coords point;
+	struct device_coord_rect tool_rect;
+	int32_t pressure;
+	struct touch_axis axis;
+	int32_t tool_type;
 };

 struct libinput_event_gesture {
@@ -193,6 +201,7 @@
 	int cancelled;
 	struct normalized_coords delta;
 	struct normalized_coords delta_unaccel;
+	struct sloted_coords_info solt_touches;
 	double scale;
 	double angle;
 };
@@ -208,6 +217,7 @@
 	struct libinput_tablet_tool *tool;
 	enum libinput_tablet_tool_proximity_state proximity_state;
 	enum libinput_tablet_tool_tip_state tip_state;
+	int32_t mt_tool_type;
 };

 struct libinput_event_tablet_pad {
@@ -392,6 +402,18 @@
 	return (struct libinput_event_touch *) event;
 }

+LIBINPUT_EXPORT struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+	return (struct libinput_event_touch *) event;
+}
+
 LIBINPUT_EXPORT struct libinput_event_gesture *
 libinput_event_get_gesture_event(struct libinput_event *event)
 {
@@ -459,6 +481,19 @@
 	return (struct libinput_event_switch *) event;
 }

+LIBINPUT_EXPORT int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&(event->base)),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+               LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+	return event->mt_tool_type;
+}
+
 LIBINPUT_EXPORT uint32_t
 libinput_event_keyboard_get_time(struct libinput_event_keyboard *event)
 {
@@ -851,6 +886,20 @@
 }

 LIBINPUT_EXPORT double
+libinput_event_touch_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
+}
+
+LIBINPUT_EXPORT double
 libinput_event_touch_get_y_transformed(struct libinput_event_touch *event,
 				       uint32_t height)
 {
@@ -866,7 +915,7 @@
 }

 LIBINPUT_EXPORT double
-libinput_event_touch_get_y(struct libinput_event_touch *event)
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event)
 {
 	struct evdev_device *device = evdev_device(event->base.device);

@@ -876,9 +925,358 @@
 			   LIBINPUT_EVENT_TOUCH_DOWN,
 			   LIBINPUT_EVENT_TOUCH_MOTION);

+	return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->tool_rect.x, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->tool_rect.y, height);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.w);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->tool_rect.w, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.h);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->tool_rect.h, height);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->slot;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->seat_slot;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->point.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
 	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
 }

+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.w);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.h);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		return 0.0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		return 0.0;
+	}
+	double range = evDevice->pressureMax;
+	if (range == 0.0) {
+		return 0.0;
+	}
+	double value = event->pressure / range;
+	return max(0.0, value);
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		libinput_log_printf("device is nullptr\n");
+		return 0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		libinput_log_printf("evdev_device is nullptr\n");
+		return 0;
+	}
+	const struct input_absinfo* absInfo = libevdev_get_abs_info(evDevice->evdev, ABS_MT_TOUCH_MAJOR);
+	if (absInfo == NULL) {
+		libinput_log_printf("ABS_MT_TOUCH_MAJOR absInfo is nullptr\n");
+		return 0;
+	}
+	if (event->axis.major > absInfo->maximum || event->axis.major < 0) {
+		libinput_log_printf(" major = %d > absInfo->maximum\n", event->axis.major);
+		return 0;
+	}
+    return event->axis.major;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		libinput_log_printf("device is nullptr\n");
+		return 0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		libinput_log_printf("evdev_device is nullptr\n");
+		return 0;
+	}
+	const struct input_absinfo* absInfo = libevdev_get_abs_info(evDevice->evdev, ABS_MT_TOUCH_MINOR);
+	if (absInfo == NULL) {
+		libinput_log_printf("ABS_MT_TOUCH_MAJOR absInfo is nullptr\n");
+		return 0;
+	}
+	if (event->axis.minor > absInfo->maximum || event->axis.minor < 0) {
+		libinput_log_printf(" major = %d > absInfo->maximum\n", event->axis.minor);
+		return 0;
+	}
+    return event->axis.minor;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->tool_type;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType)
+{
+	if (device == NULL) {
+		return -1;
+	}
+	return evdev_device_touchpad_btn_tool_type_down((struct evdev_device *)device, btnToolType);
+}
+
 LIBINPUT_EXPORT uint32_t
 libinput_event_gesture_get_time(struct libinput_event_gesture *event)
 {
@@ -1031,6 +1429,18 @@
 	return event->angle;
 }

+LIBINPUT_EXPORT struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(
+	struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE);
+
+	return &event->solt_touches;
+}
+
 LIBINPUT_EXPORT int
 libinput_event_tablet_tool_x_has_changed(
 				struct libinput_event_tablet_tool *event)
@@ -1048,6 +1458,24 @@
 }

 LIBINPUT_EXPORT int
+libinput_has_event_led_type(struct libinput_device *device)
+{
+    return evdev_has_event_type((struct evdev_device *)device, EV_LED);
+}
+
+LIBINPUT_EXPORT int
+libinput_get_funckey_state(struct libinput_device *device,  unsigned int code)
+{
+    return evdev_get_event_value((struct evdev_device *)device, EV_LED, code);
+}
+
+LIBINPUT_EXPORT int
+libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state)
+{
+    return evdev_kernel_set_led_value((struct evdev_device *)device, code, state);
+}
+
+LIBINPUT_EXPORT int
 libinput_event_tablet_tool_y_has_changed(
 				struct libinput_event_tablet_tool *event)
 {
@@ -1806,11 +2234,8 @@
 	/* If we fail, we'll fail next time too */
 	libinput->quirks_initialized = true;

-	data_path = getenv("LIBINPUT_QUIRKS_DIR");
-	if (!data_path) {
-		data_path = LIBINPUT_QUIRKS_DIR;
-		override_file = LIBINPUT_QUIRKS_OVERRIDE_FILE;
-	}
+		data_path = (char *)LIBINPUT_QUIRKS_DIR;
+		override_file = (char *)LIBINPUT_QUIRKS_OVERRIDE_FILE;

 	quirks = quirks_init_subsystem(data_path,
 				       override_file,
@@ -2311,6 +2736,9 @@
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		capability = "CAP_SWITCH";
 		break;
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+        capability = "CAP_JOYSTICK";
+        break;
 	}

 	log_bug_libinput(device->seat->libinput,
@@ -2458,7 +2886,11 @@
 			uint64_t time,
 			int32_t slot,
 			int32_t seat_slot,
-			const struct device_coords *point)
+			int32_t pressure,
+            const struct touch_axis *axis,
+			const struct device_coords *point,
+			int32_t tool_type,
+			const struct device_coord_rect *tool_rect)
 {
 	struct libinput_event_touch *touch_event;

@@ -2472,6 +2904,10 @@
 		.slot = slot,
 		.seat_slot = seat_slot,
 		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = *axis,
+		.tool_type = tool_type,
 	};

 	post_device_event(device, time,
@@ -2484,7 +2920,11 @@
 			  uint64_t time,
 			  int32_t slot,
 			  int32_t seat_slot,
-			  const struct device_coords *point)
+			  int32_t pressure,
+              const struct touch_axis *axis,
+			  const struct device_coords *point,
+			  int32_t tool_type,
+			  const struct device_coord_rect *tool_rect)
 {
 	struct libinput_event_touch *touch_event;

@@ -2498,6 +2938,10 @@
 		.slot = slot,
 		.seat_slot = seat_slot,
 		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = *axis,
+		.tool_type = tool_type,
 	};

 	post_device_event(device, time,
@@ -2509,7 +2953,8 @@
 touch_notify_touch_up(struct libinput_device *device,
 		      uint64_t time,
 		      int32_t slot,
-		      int32_t seat_slot)
+		      int32_t seat_slot,
+		      int32_t tool_type)
 {
 	struct libinput_event_touch *touch_event;

@@ -2522,6 +2967,7 @@
 		.time = time,
 		.slot = slot,
 		.seat_slot = seat_slot,
+		.tool_type = tool_type,
 	};

 	post_device_event(device, time,
@@ -2574,6 +3020,90 @@
 }

 void
+touchpad_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			int32_t pressure,
+			int32_t tool_type,
+			struct touch_axis axis,
+			const struct device_coords *point,
+			const struct device_coord_rect *tool_rect)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = axis,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			  &touch_event->base);
+}
+
+void
+touchpad_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  int32_t pressure,
+			  int32_t tool_type,
+			  struct touch_axis axis,
+			  const struct device_coords *point,
+			  const struct device_coord_rect *tool_rect)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+		.tool_rect = *tool_rect,
+		.axis = axis,
+		.pressure = pressure,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_MOTION,
+			  &touch_event->base);
+}
+
+void
+touchpad_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot,
+		      int32_t tool_type,
+			  struct touch_axis axis)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.axis = axis,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_UP,
+			  &touch_event->base);
+}
+
+void
 tablet_notify_axis(struct libinput_device *device,
 		   uint64_t time,
 		   struct libinput_tablet_tool *tool,
@@ -2591,6 +3121,7 @@
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.tip_state = tip_state,
 		.axes = *axes,
+		.mt_tool_type = tool->mt_tool_type,
 	};

 	memcpy(axis_event->changed_axes,
@@ -2621,6 +3152,7 @@
 		.tip_state = LIBINPUT_TABLET_TOOL_TIP_UP,
 		.proximity_state = proximity_state,
 		.axes = *axes,
+		.mt_tool_type = tool->mt_tool_type,
 	};
 	memcpy(proximity_event->changed_axes,
 	       changed_axes,
@@ -2650,6 +3182,7 @@
 		.tip_state = tip_state,
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.axes = *axes,
+		.mt_tool_type = tool->mt_tool_type,
 	};
 	memcpy(tip_event->changed_axes,
 	       changed_axes,
@@ -2688,6 +3221,7 @@
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.tip_state = tip_state,
 		.axes = *axes,
+		.mt_tool_type = tool->mt_tool_type,
 	};

 	post_device_event(device,
@@ -2814,6 +3348,7 @@
 	       int cancelled,
 	       const struct normalized_coords *delta,
 	       const struct normalized_coords *unaccel,
+	       const struct sloted_coords_info *solt_touches,
 	       double scale,
 	       double angle)
 {
@@ -2834,6 +3369,12 @@
 		.angle = angle,
 	};

+	if (solt_touches != NULL) {
+		gesture_event->solt_touches = *solt_touches;
+	} else {
+        memset(&gesture_event->solt_touches, 0, sizeof(struct sloted_coords_info));
+    }
+
 	post_device_event(device, time, type,
 			  &gesture_event->base);
 }
@@ -2844,9 +3385,10 @@
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel)
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *solt_touches)
 {
-	gesture_notify(device, time, type, finger_count, 0, delta, unaccel,
+	gesture_notify(device, time, type, finger_count, 0, delta, unaccel, solt_touches,
 		       0.0, 0.0);
 }

@@ -2859,7 +3401,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };

 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_SWIPE_END,
-		       finger_count, cancelled, &zero, &zero, 0.0, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, 0.0, 0.0);
 }

 void
@@ -2873,7 +3415,7 @@
 		     double angle)
 {
 	gesture_notify(device, time, type, finger_count, 0,
-		       delta, unaccel, scale, angle);
+		       delta, unaccel, NULL, scale, angle);
 }

 void
@@ -2886,7 +3428,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };

 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_PINCH_END,
-		       finger_count, cancelled, &zero, &zero, scale, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, scale, 0.0);
 }

 void
@@ -2972,6 +3514,92 @@
 	libinput->events_in = (libinput->events_in + 1) % libinput->events_len;
 }

+
+LIBINPUT_EXPORT void
+libinput_post_handle_event(struct libinput* libinput, struct libinput_event* event)
+{
+	libinput_post_event(libinput, event);
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event)
+{
+    require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_axis*
+libinput_event_get_joystick_axis_event(struct libinput_event* event)
+{
+	require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+		LIBINPUT_EVENT_POINTER_AXIS);
+
+    return (struct libinput_event_joystick_axis*)event;
+}
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return (event->axis_value_mask & (uint32_t)axis);
+}
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return event->time;
+}
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	switch (axis) {
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X:
+	return &event->abs_x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y:
+	return &event->abs_y;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z:
+	return &event->abs_z;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX:
+	return &event->abs_rx;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY:
+	return &event->abs_ry;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ:
+	return &event->abs_rz;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE:
+	return &event->abs_throttle;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X:
+	return &event->abs_hat0x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y:
+	return &event->abs_hat0y;
+	default:
+	break;
+	}
+
+	return NULL;
+}
+
 LIBINPUT_EXPORT struct libinput_event *
 libinput_get_event(struct libinput *libinput)
 {
@@ -3055,12 +3683,169 @@
 	return evdev_device_get_sysname((struct evdev_device *) device);
 }

+LIBINPUT_EXPORT const char*
+libinput_device_get_phys(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_phys(evdev);
+}
+
+LIBINPUT_EXPORT const char*
+libinput_device_get_uniq(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_uniq(evdev);
+}
+
 LIBINPUT_EXPORT const char *
 libinput_device_get_name(struct libinput_device *device)
 {
 	return evdev_device_get_name((struct evdev_device *) device);
 }

+LIBINPUT_EXPORT enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device)
+{
+	if(device == NULL)
+	{
+		return EVDEV_UDEV_TAG_INPUT;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	enum evdev_device_udev_tags udev_tags;
+	udev_tags = evdev_device_get_udev_device_tags(evdevDevice);
+    return udev_tags;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode)
+{
+	if(device == NULL)
+	{
+		return EVDEV_UDEV_TAG_INPUT;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_KEY)) {
+		return 0;
+	}
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_KEY, keyCode)) {
+		return 1;
+	}
+	return 0;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->minimum;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->maximum;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->fuzz;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->flat;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->resolution;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device)
+{
+	return evdev_device_get_id_bustype((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_version(struct libinput_device* device)
+{
+	return evdev_device_get_id_version((struct evdev_device *) device);
+}
+
 LIBINPUT_EXPORT unsigned int
 libinput_device_get_id_product(struct libinput_device *device)
 {
@@ -3148,6 +3933,15 @@
 }

 LIBINPUT_EXPORT int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType)
+{
+	if (device == NULL) {
+		return -1;
+	}
+	return evdev_device_touch_btn_tool_type_down((struct evdev_device *)device, btnToolType);
+}
+
+LIBINPUT_EXPORT int
 libinput_device_switch_has_switch(struct libinput_device *device,
 				  enum libinput_switch sw)
 {
@@ -3347,6 +4141,19 @@
 }

 LIBINPUT_EXPORT struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
 libinput_event_gesture_get_base_event(struct libinput_event_gesture *event)
 {
 	require_event_type(libinput_event_get_context(&event->base),
@@ -4378,3 +5185,162 @@
 	}
 }
 #endif
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(event),
+		event->type,
+		NULL,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_joystick_button_time(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+        event->base.type,
+        0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->time;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->key;
+}
+
+LIBINPUT_EXPORT enum libinput_key_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->seat_key_count;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+        LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->value;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_pressure(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TOUCH_DOWN,
+		LIBINPUT_EVENT_TOUCH_UP,
+		LIBINPUT_EVENT_TOUCH_MOTION,
+		LIBINPUT_EVENT_TOUCH_CANCEL,
+		LIBINPUT_EVENT_TOUCH_FRAME);
+
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		return 0.0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		return 0.0;
+	}
+
+	const struct input_absinfo* absInfo = evDevice->is_mt ? libevdev_get_abs_info(evDevice->evdev, ABS_MT_PRESSURE)
+		: libevdev_get_abs_info(evDevice->evdev, ABS_PRESSURE);
+	if (!absInfo) {
+		return 0.0;
+	}
+	double range = absInfo->maximum;
+	double value = event->pressure / range;
+	return max(0.0, value);
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return event->tool_type;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+                event->base.type,
+                0,
+                LIBINPUT_EVENT_TOUCH_DOWN,
+                LIBINPUT_EVENT_TOUCH_UP,
+                LIBINPUT_EVENT_TOUCH_MOTION,
+                LIBINPUT_EVENT_TOUCH_CANCEL,
+				LIBINPUT_EVENT_TOUCH_FRAME);
+
+    return event->axis.major;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+                event->base.type,
+                0,
+                LIBINPUT_EVENT_TOUCH_DOWN,
+                LIBINPUT_EVENT_TOUCH_UP,
+                LIBINPUT_EVENT_TOUCH_MOTION,
+                LIBINPUT_EVENT_TOUCH_CANCEL,
+				LIBINPUT_EVENT_TOUCH_FRAME);
+
+    return event->axis.minor;
+}
+
diff -Naur old/src/libinput.h new/src/libinput.h
--- old/src/libinput.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput.h	2021-01-01 00:00:00.000000000 +0800
@@ -196,6 +196,22 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = 1 << 0,
+    EVDEV_UDEV_TAG_KEYBOARD = 1 << 1,
+    EVDEV_UDEV_TAG_MOUSE = 1 << 2,
+    EVDEV_UDEV_TAG_TOUCHPAD = 1 << 3,
+    EVDEV_UDEV_TAG_TOUCHSCREEN = 1 << 4,
+    EVDEV_UDEV_TAG_TABLET = 1 << 5,
+    EVDEV_UDEV_TAG_JOYSTICK = 1 << 6,
+    EVDEV_UDEV_TAG_ACCELEROMETER = 1 << 7,
+    EVDEV_UDEV_TAG_TABLET_PAD = 1 << 8,
+    EVDEV_UDEV_TAG_POINTINGSTICK = 1 << 9,
+    EVDEV_UDEV_TAG_TRACKBALL = 1 << 10,
+    EVDEV_UDEV_TAG_SWITCH = 1 << 11,
 };

 /**
@@ -315,6 +331,49 @@
 };

 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOW = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = 1 << 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = 1 << 1,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = 1 << 2,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = 1 << 3,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = 1 << 4,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = 1 << 5,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = 1 << 6,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = 1 << 7,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = 1 << 8,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = 1 << 9,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = 1 << 10,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = 1 << 11,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = 1 << 12,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = 1 << 13,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = 1 << 14,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = 1 << 15,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = 1 << 16,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = 1 << 17,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = 1 << 18,
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	int32_t is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -387,6 +446,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };

+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -754,6 +824,10 @@
 	 */
 	LIBINPUT_EVENT_TOUCH_FRAME,

+	LIBINPUT_EVENT_TOUCHPAD_DOWN = 550,
+	LIBINPUT_EVENT_TOUCHPAD_UP,
+	LIBINPUT_EVENT_TOUCHPAD_MOTION,
+
 	/**
 	 * One or more axes have changed state on a device with the @ref
 	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
@@ -1001,6 +1075,19 @@
 /**
  * @ingroup event
  *
+ * Return the touchpad event that is this input event. If the event type does
+ * not match the touchpad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touchpad_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
  * Return the gesture event that is this input event. If the event type does
  * not match the gesture event types, this function returns NULL.
  *
@@ -1673,6 +1760,120 @@
 				       uint32_t height);

 /**
+ * @brief 获取触摸屏的工具类型区域属性
+ */
+int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_x_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_y_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area. To get the corresponding output
+ * screen width, use
+ * libinput_event_touch_get_tool_width_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current width
+ */
+double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area, converted to screen width.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return Convert current width to screen width
+ */
+double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area. To get the corresponding output
+ * screen height, use
+ * libinput_event_touch_get_tool_height_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current height
+ */
+double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area, converted to screen height.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return Convert current height to screen height
+ */
+double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
  * @ingroup event_touch
  *
  * @return The generic libinput_event of this event
@@ -1681,6 +1882,228 @@
 libinput_event_touch_get_base_event(struct libinput_event_touch *event);

 /**
+ * @defgroup event_touch Touchpad events
+ *
+ * Events from absolute touchpad devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touchpad event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touchpad event has no assigned slot, for example if it is from a
+ * single touchpad device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The slot of this touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touchpad event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touchpad point.
+ *
+ * Events from single touchpad devices will be represented as one individual
+ * touchpad point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The seat slot of the touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the pressure of the touch pad
+ *
+ * @param event The libinput touch event
+ * @return Touchpad pressure value
+ *
+ */
+double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The long axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The short axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板的工具类型区域属性
+ */
+int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板工具类型按钮是否按下
+ */
+int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the X coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The X coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the Y coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The Y coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the width of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The width of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the height of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The height of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event);
+
+/**
  * @defgroup event_gesture Gesture events
  *
  * Gesture events are generated when a gesture is recognized on a touchpad.
@@ -1893,6 +2316,42 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);

 /**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
+ * @brief Obtain the device values the EV_LED event type
+ *
+ * @param device  A current input device
+ * @return int Obtained is Supported
+ */
+int libinput_has_event_led_type(struct libinput_device *device);
+
+/**
+ * @brief Obtain the function key enablement status of a keyboard device
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @return int Obtained state
+ */
+int libinput_get_funckey_state(struct libinput_device *device, unsigned int code);
+
+/**
+ * @brief Turn an LED on or off. Convenience function, if you need to modify multiple
+ * LEDs simultaneously, use libinput_set_led_state() instead.
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @param state value Specifies whether to turn the LED on or off
+ * @return int 0 on success, or a negative errno on failure
+ */
+int libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -2620,6 +3079,19 @@
 /**
  * @ingroup event_tablet
  *
+ * Get the stylus event type reported from evdev_tablet
+ *
+ * @param event The libinput tablet tool event
+ * @return Tool type for stylus events
+ *
+ * @since 1.2
+ */
+int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
  * Return the high-level tool type for a tool object.
  *
  * The high level tool describes general interaction expected with the tool.
@@ -3466,6 +3938,46 @@
 int
 libinput_dispatch(struct libinput *libinput);

+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_axis *
+libinput_event_get_joystick_axis_event(struct libinput_event *event);
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -3936,6 +4448,42 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);

+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
+/**  @brief   设备按键能力查询*/
+int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode);
+
+/**  @brief   获取设备特定轴的最小值*/
+int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的最大值*/
+int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的fuzz值*/
+int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的flat值*/
+int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的resolution值*/
+int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备的bustype值*/
+unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device);
+
+/**  @brief   获取设备的version值*/
+unsigned int
+libinput_device_get_id_version(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -4146,6 +4694,12 @@
 libinput_device_touch_get_touch_count(struct libinput_device *device);

 /**
+ * @brief 获取触摸屏工具类型按钮是否按下
+ */
+int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
  * @ingroup device
  *
  * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
@@ -5928,7 +6482,102 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);

+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ *
+ * @since 1.4
+ */
+double
+libinput_event_touch_get_pressure(struct libinput_event_touch* event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Long axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Short axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+
+const char*
+libinput_device_get_uniq(struct libinput_device* device);
+
+enum libinput_key_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/src/udev-seat.c new/src/udev-seat.c
--- old/src/udev-seat.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/udev-seat.c	2021-01-01 00:00:00.000000000 +0800
@@ -189,6 +189,7 @@

 		/* Skip unconfigured device. udev will send an event
 		 * when device is fully configured  */
+/*
 		if (!udev_device_get_is_initialized(device)) {
 			log_debug(&input->base,
 				  "%-7s - skip unconfigured input device '%s'\n",
@@ -197,6 +198,13 @@
 			udev_device_unref(device);
 			continue;
 		}
+*/
+		if (!udev_device_get_is_initialized(device)) {
+			log_info(&input->base,
+				  "%-7s - unconfigured input device '%s'\n",
+				  sysname,
+				  udev_device_get_devnode(device));
+		}

 		if (device_added(device, input, NULL) < 0) {
 			udev_device_unref(device);
diff -Naur old/src/util-strings.h new/src/util-strings.h
--- old/src/util-strings.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/util-strings.h	2021-01-01 00:00:00.000000000 +0800
@@ -281,7 +281,7 @@
 	if (npairs == 0)
 		goto error;

-	result = zalloc(npairs * sizeof *result);
+	result = (struct key_value_double *)zalloc(npairs * sizeof *result);

 	for (pair = pairs; *pair; pair++) {
 		char **kv = strv_from_string(*pair, kv_separator);
diff -Naur old/src/util-time.h new/src/util-time.h
--- old/src/util-time.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/util-time.h	2021-01-01 00:00:00.000000000 +0800
@@ -97,7 +97,8 @@
 static inline struct human_time
 to_human_time(uint64_t us)
 {
-	struct human_time t;
+	uint64_t l = 0;
+	struct human_time t = {0, NULL};
 	struct c {
 		const char *unit;
 		unsigned int change_from_previous;
@@ -108,7 +109,7 @@
 		{"s", 1000, 120},
 		{"min", 60, 120},
 		{"h", 60, 48},
-		{"d", 24, ~0},
+		{"d", 24, ~l},
 	};
 	struct c *c;
 	uint64_t value = us;
@@ -121,6 +122,6 @@
 			return t;
 		}
 	}
-
-	assert(!"We should never get here");
+return t;
+	//assert(1);
 }
diff -Naur old/tools/libinput-debug-events.c new/tools/libinput-debug-events.c
--- old/tools/libinput-debug-events.c	2021-01-01 00:00:00.000000000 +0800
+++ new/tools/libinput-debug-events.c	2021-01-01 00:00:00.000000000 +0800
@@ -101,6 +101,15 @@
 	case LIBINPUT_EVENT_TOUCH_FRAME:
 		type = "TOUCH_FRAME";
 		break;
+	case LIBINPUT_EVENT_TOUCHPAD_DOWN:
+		type = "TOUCHPAD_DOWN";
+		break;
+	case LIBINPUT_EVENT_TOUCHPAD_MOTION:
+		type = "TOUCHPAD_MOTION";
+		break;
+	case LIBINPUT_EVENT_TOUCHPAD_UP:
+		type = "TOUCHPAD_UP";
+		break;
 	case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
 		type = "GESTURE_SWIPE_BEGIN";
 		break;
@@ -274,6 +283,10 @@
 					   LIBINPUT_DEVICE_CAP_SWITCH))
 		printq("S");

+    if (libinput_device_has_capability(dev,
+        LIBINPUT_DEVICE_CAP_JOYSTICK))
+        printq("JOYSTICK");
+
 	if (libinput_device_get_size(dev, &w, &h) == 0)
 		printq("  size %.0fx%.0fmm", w, h);

@@ -530,6 +543,15 @@
 }

 static void
+print_touchpad_event_without_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touchpad_event(ev);
+
+	print_event_time(libinput_event_touchpad_get_time(t));
+	printq("\n");
+}
+
+static void
 print_proximity_event(struct libinput_event *ev)
 {
 	struct libinput_event_tablet_tool *t = libinput_event_get_tablet_tool_event(ev);
@@ -647,6 +669,21 @@
 }

 static void
+print_touchpad_event_with_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touchpad_event(ev);
+	double xmm = libinput_event_touchpad_get_x(t);
+	double ymm = libinput_event_touchpad_get_y(t);
+
+	print_event_time(libinput_event_touchpad_get_time(t));
+
+	printq("%d (%d) %5.2f/%5.2fmm\n",
+	       libinput_event_touchpad_get_slot(t),
+	       libinput_event_touchpad_get_seat_slot(t),
+	       xmm, ymm);
+}
+
+static void
 print_gesture_event_without_coords(struct libinput_event *ev)
 {
 	struct libinput_event_gesture *t = libinput_event_get_gesture_event(ev);
@@ -869,6 +906,15 @@
 		case LIBINPUT_EVENT_TOUCH_FRAME:
 			print_touch_event_without_coords(ev);
 			break;
+		case LIBINPUT_EVENT_TOUCHPAD_DOWN:
+			print_touchpad_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCHPAD_MOTION:
+			print_touchpad_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCHPAD_UP:
+			print_touchpad_event_without_coords(ev);
+			break;
 		case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
 			print_gesture_event_without_coords(ev);
 			break;
diff -Naur old/tools/libinput-record.c new/tools/libinput-record.c
--- old/tools/libinput-record.c	2021-01-01 00:00:00.000000000 +0800
+++ new/tools/libinput-record.c	2021-01-01 00:00:00.000000000 +0800
@@ -50,6 +50,7 @@
 #include "util-time.h"
 #include "util-input-event.h"
 #include "util-macros.h"
+#include "hm_missing.h"

 static const int FILE_VERSION_NUMBER = 1;

diff -Naur old/udev/libinput-device-group.c new/udev/libinput-device-group.c
--- old/udev/libinput-device-group.c	2021-01-01 00:00:00.000000000 +0800
+++ new/udev/libinput-device-group.c	2021-01-01 00:00:00.000000000 +0800
@@ -138,7 +138,7 @@
 				*product_id = pid;
 				best_dist = dist;

-				free(*phys_attr);
+				free((char*)*phys_attr);
 				*phys_attr = strdup(phys);
 			}
 		}
